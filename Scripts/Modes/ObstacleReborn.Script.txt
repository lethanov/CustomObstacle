#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const CompatibleMapTypes  "ObstacleRebornArena, ObstacleTitleArena, ObstacleArena"
#Const Version             "7"
#Const ScriptName          "ObstacleReborn.Script.txt"

#Include "Libs/Nadeo/Settings.Script.txt" as Settings
#Include "TextLib" as TextLib
#Include "MathLib" as MathLib
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Layers.Script.txt" as Layers
#Include "Libs/Lethan/ChronoObs.Script.txt" as Chrono


// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_Revision 7

// ---------------------------------- //
// Globales
// ---------------------------------- //
declare CSmMapLandmark G_MainSpawn;
declare CSmMapLandmark[Integer] G_Checkpoints;

declare Integer G_CheckpointsCount;

declare Integer[Ident] G_StartsTime;
declare Integer[Ident] G_PreviousTimes;
declare Integer[Ident] G_BestTimes;

declare Integer[Ident] G_CheckpointNext;
declare Integer[Ident] G_Respawns;
declare Integer[Ident] G_Finish;

declare Boolean[Ident] G_Started;
declare Boolean[Ident] G_Finished;



declare CUILayer G_DebugInfo;

declare Text G_GamePhase;

***StartMap***
***
G_GamePhase = "init";

Clear();
InitObstacle();
InitInterface();

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedHidden;

Chrono::Load();

sleep(1000);
***

***PlayLoop***
***
if(G_GamePhase == "init"){
	declare Text authorMsg = "Author : $z" ^ Map.AuthorNickName ^ " $z(" ^ Map.AuthorLogin ^ ")";
	Message::SendStatusMessage(authorMsg, 5000, 3, CUIConfig::EUISound::Silence, 0);
	Message::SendBigMessage(MapName, 5000, 3, CUIConfig::EUISound::EndRound, 0);
	
	sleep(2000);
	
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	StartTime = Now;
	EndTime = -1;
	
	G_GamePhase = "play";
}
if(G_GamePhase == "play"){
	UpdatePlayersObstacle();
}
Message::Loop();
***

***EndMap***
***
Clear();
//Code to execute at the end of a match/map
***


// ---------------------------------- //
// Functions
// ---------------------------------- //

Void ChangeWeapon(CSmPlayer _Player){
	if(_Player.CapturedLandmark != Null){
		if(TextLib::SubText(_Player.CapturedLandmark.Tag, 0, 10) == "Checkpoint"){
			//Retro compatibility
			if(TextLib::SubText(_Player.CapturedLandmark.Tag, 10, 5) == "Type2" && GetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket) != 10){
				SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, 10);
				SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 10);
				_Player.AmmoGain = 10.0;
			} else if(TextLib::SubText(_Player.CapturedLandmark.Tag, 10, 5) == "Type1" && GetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket) != 0){
				SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, 0);
				SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
				_Player.AmmoGain = 0.0;
			} else if(TextLib::SubText(_Player.CapturedLandmark.Tag, 10, 5) == "" && GetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket) != 4){
				SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, 4);
				SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 4);
				_Player.AmmoGain = 1.0;
			}
		}
	} else {
		if(TextLib::SubText(G_MainSpawn.Tag, 0, 5) == "Spawn"){
			if(TextLib::SubText(G_MainSpawn.Tag, 5, 5) == "Type1"){
				SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
				_Player.AmmoGain = 0.0;
			} else if(TextLib::SubText(G_MainSpawn.Tag, 5, 5) == "Type1"){
				SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 10);
				_Player.AmmoGain = 10.0;
			} else if(TextLib::SubText(G_MainSpawn.Tag, 5, 5) == ""){
				SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 4);
				_Player.AmmoGain = 1.0;
			}
		}
	}
}

//Spawn player
Void OSpawnPlayer(CSmPlayer _Player){
	_Player.ArmorMax = 100;
	
	ChangeWeapon(_Player);
	
	SpawnPlayer(_Player, 0, 100, G_MainSpawn.PlayerSpawn, Now);
}

//Respawn player
Void OSRespawnPlayer(CSmPlayer _Player){
	if(G_CheckpointNext[_Player.Id] == 1 || (_Player.CapturedLandmark != Null && TextLib::SubText(_Player.CapturedLandmark.Tag, 0, 10) == "Checkpoint")){
		UnspawnPlayer(_Player);
		Chrono::Stop(_Player.Id);
		G_CheckpointNext[_Player.Id] = 0;
		Chrono::Reset(_Player.Id);
		G_Finished[_Player.Id] = True;
	} else {
		RespawnPlayer(_Player, G_Checkpoints[G_CheckpointNext[_Player.Id] - 1]);
		G_Respawns[_Player.Id] += 1;
	}
}

//Update Player Manialink Interface
Void UpdatePlayerInterface(CSmPlayer _Player){
	declare UI <=> UIManager.GetUI(_Player); //Get UI for player
	declare cpNext = G_CheckpointNext[_Player.Id]; //Get next checkpoint

	UI.MarkersXML = "";
	
	UI.ManialinkPage = "";
	
	if(!_Player.RequestsSpectate){
		if(G_Started[_Player.Id] && !G_Finished[_Player.Id]){
			if(cpNext != G_CheckpointsCount){
				UI.MarkersXML = """<marker label="Checkpoint {{{cpNext}}}" pos="{{{G_Checkpoints[cpNext].Position.X}}} {{{G_Checkpoints[cpNext].Position.Y + 2}}} {{{G_Checkpoints[cpNext].Position.Z}}}" />""";
			} else {
				UI.MarkersXML = """<marker label="Goal" pos="{{{G_Checkpoints[cpNext].Position.X}}} {{{G_Checkpoints[cpNext].Position.Y + 2}}} {{{G_Checkpoints[cpNext].Position.Z}}}" />""";
			}
		}
		
		declare progress = G_CheckpointNext[_Player.Id] - 1;
		
		declare Text BestTheoreticalText;
		declare Text BestTimePersonal;
		declare Text PreviousTimePersonal;
		declare Text NextCheckPersonal;
		declare Text PreviousCheckPersonal;
		
		declare Integer[Integer] CheckpointsTimes for _Player;
		declare Integer[Integer] CheckpointsIntTimes for _Player;
			
		declare Integer[Integer] CheckpointsBestTimes for _Player;
		declare Integer[Integer] CheckpointsBestIntTimes for _Player;
		
		declare BestTheoretical = 0;
		foreach(CPTime, CheckpointsBestIntTimes){
			BestTheoretical += CPTime;
		}
		
		if(G_Finish[_Player.Id] != 0){
			BestTheoreticalText = TextLib::TimeToText(BestTheoretical, True);
		} else {
			BestTheoreticalText = "--:--,--";
		}
		
		if(G_Finish[_Player.Id] != 0 && G_CheckpointNext[_Player.Id] != 0 && CheckpointsTimes[G_CheckpointNext[_Player.Id]] != 0){

			NextCheckPersonal = TextLib::TimeToText(CheckpointsBestTimes[G_CheckpointNext[_Player.Id]],True) ^ " - [" ^ TextLib::TimeToText(CheckpointsBestIntTimes[G_CheckpointNext[_Player.Id]], True) ^ "]";
		} else {
			NextCheckPersonal = "--:--,--";
		}
		
		if(G_CheckpointNext[_Player.Id] > 1){
			PreviousCheckPersonal = TextLib::TimeToText(CheckpointsBestTimes[G_CheckpointNext[_Player.Id] - 1],True) ^ " - [" ^ TextLib::TimeToText(CheckpointsBestIntTimes[G_CheckpointNext[_Player.Id] - 1], True) ^ "]";
		} else {
			PreviousCheckPersonal = "--:--,--";
		}
		
		if(G_PreviousTimes[_Player.Id] != 0){
			PreviousTimePersonal = TextLib::TimeToText(G_PreviousTimes[_Player.Id], True);
		} else {
			PreviousTimePersonal = "--:--.--";	
		}
		
		if(G_BestTimes[_Player.Id] != 0){
			BestTimePersonal = TextLib::TimeToText(G_BestTimes[_Player.Id], True);
		} else {
			BestTimePersonal = "--:--.--";	
		}
		

		if(progress < 0) progress = 0;
		
		
		UI.ManialinkPage = """
			<label posn="-48 -76 0" halign="center" valign="center" style="TextButtonMedium" text="$sProgress : {{{progress}}}/{{{G_CheckpointsCount}}}"/>
			<label posn="155 -80 0" halign="right" valign="center" style="TextButtonMedium" text="$sRuns : {{{G_Finish[_Player.Id]}}}"/>
			<label posn="155 -85 0" halign="right" valign="center" style="TextButtonMedium" text="$sRespawns : {{{G_Respawns[_Player.Id]}}}"/>
			<!--<quad posn="162 -13" sizen="50 11" halign="right" valign="center" style="Bgs1" substyle="BgGradV"/>-->
			<quad posn="162 -53" sizen="50 11" halign="right" valign="center" style="Bgs1" substyle="BgGradV"/>
			<!--<quad posn="162 -28" sizen="50 11" halign="right" valign="center" style="Bgs1" substyle="BgGradV"/>-->
			<quad posn="161 -68" sizen="30 15" halign="right" valign="center" style="Bgs1" substyle="BgGradV"/>
			
			<label posn="128 -65 0" halign="center" valign="center" sizen="20 5" text="$sBest time" textsize="1" style="TextButtonMedium"/>
			<label posn="128 -71 0" halign="center" valign="center" sizen="20 5" text="$sPrevious" textsize="1" style="TextButtonMedium"/>
			
			<label posn="148 -65 0" sizen="19 5" text="$0f0{{{BestTimePersonal}}}" style="TextRaceChrono" textsize="3" halign="center" valign="center"/>
			<label posn="148 -71 0" sizen="19 5" text="$050{{{PreviousTimePersonal}}}" style="TextRaceChrono" textsize="3" halign="center" valign="center"/>
			
			<!--<label posn="157 -43 0" sizen="42 5" text="$ddd{{{NextCheckPersonal}}}" style="TextRaceChrono" textsize="3" halign="right" valign="center"/>
			<label posn="157 -28 0" sizen="42 5" text="$999{{{PreviousCheckPersonal}}}" style="TextRaceChrono" textsize="3" halign="right" valign="center"/>-->
			<label posn="157 -53 0" sizen="42 5" text="$f93{{{BestTheoreticalText}}}" style="TextRaceChrono" textsize="4" halign="right" valign="center"/>
			
			<!--<label posn="121 -37 0" sizen="34 6" style="TextButtonMedium" text="$sNext Checkpoint" id="time" halign="center" valign="center"/>
			<label posn="121 -22 0" sizen="34 6" style="TextButtonMedium" text="$sLast Checkpoint" id="time" halign="center" valign="center"/>-->
			<label posn="121 -47 0" sizen="34 6" style="TextButtonMedium" text="$sBest Theoretical" id="time" halign="center" valign="center"/>
			""";
	}
}

//Checkpoint Managament - INCLUDING FINISH
Void CheckpointManage(CSmPlayer _Player){
	declare Integer[Integer] CheckpointsTimes for _Player;
	declare Integer[Integer] CheckpointsIntTimes for _Player;
	
	declare Integer[Integer] CheckpointsBestTimes for _Player;
	declare Integer[Integer] CheckpointsBestIntTimes for _Player;
	
	declare Integer LastCheckTime for _Player;
	declare Integer diff for _Player;
	declare Integer diffInt for _Player;
	
	CheckpointsTimes[G_CheckpointNext[_Player.Id]] = Now - G_StartsTime[_Player.Id];	
	
	if(G_CheckpointNext[_Player.Id] == 1){
		LastCheckTime = Now - G_StartsTime[_Player.Id];
		CheckpointsIntTimes[G_CheckpointNext[_Player.Id]] = Now - G_StartsTime[_Player.Id];
	} else {
		LastCheckTime = CheckpointsTimes[G_CheckpointNext[_Player.Id]] - (Now - G_StartsTime[_Player.Id]);
		CheckpointsIntTimes[G_CheckpointNext[_Player.Id]] = CheckpointsTimes[G_CheckpointNext[_Player.Id]] - CheckpointsTimes[G_CheckpointNext[_Player.Id] - 1];
	}
	
	//Check if checkpoint absolute times are better
	//If first run
	if(G_Finish[_Player.Id] == 0){
		CheckpointsBestTimes[G_CheckpointNext[_Player.Id]] = CheckpointsTimes[G_CheckpointNext[_Player.Id]];
	} else {
		diff = CheckpointsTimes[G_CheckpointNext[_Player.Id]] - CheckpointsBestTimes[G_CheckpointNext[_Player.Id]];
		if(CheckpointsBestTimes[G_CheckpointNext[_Player.Id]] > CheckpointsTimes[G_CheckpointNext[_Player.Id]]){
			CheckpointsBestTimes[G_CheckpointNext[_Player.Id]] = CheckpointsTimes[G_CheckpointNext[_Player.Id]];
		}
	}
	
	//Check if checkpoint relative times are better
	if(G_Finish[_Player.Id] == 0){
		CheckpointsBestIntTimes[G_CheckpointNext[_Player.Id]] = CheckpointsIntTimes[G_CheckpointNext[_Player.Id]];
	} else {
		diffInt = CheckpointsIntTimes[G_CheckpointNext[_Player.Id]] - CheckpointsBestIntTimes[G_CheckpointNext[_Player.Id]];
		if(CheckpointsBestIntTimes[G_CheckpointNext[_Player.Id]] > CheckpointsIntTimes[G_CheckpointNext[_Player.Id]]){
			CheckpointsBestIntTimes[G_CheckpointNext[_Player.Id]] = CheckpointsIntTimes[G_CheckpointNext[_Player.Id]];
		}
	}
}

//When a player passes checkoint
Void CheckpointEvent(CSmPlayer _Player){
	declare Integer[Integer] CheckpointsTimes for _Player;
	declare Integer[Integer] CheckpointsIntTimes for _Player;
	
	declare Integer[Integer] CheckpointsBestTimes for _Player;
	declare Integer[Integer] CheckpointsBestIntTimes for _Player;
	
	declare Integer diff for _Player;
	declare Integer diffInt for _Player;
	
	CheckpointManage(_Player);
	
	declare Text diffText;
	declare Text diffIntText;
	
	diffText = "";
	diffIntText = "";
	
	declare sound = 1;
		
	if(G_Finish[_Player.Id] != 0){
		if(diff < 0){
			diffText = " ($66f" ^ TextLib::TimeToText(diff, True) ^ "$fff)";
			sound = 2;
		} else {
			diffText = " ($f66+" ^ TextLib::TimeToText(diff, True) ^ "$fff)";
			sound = 0;
		}
		if(diffInt < 0){
			diffIntText = " ($66f" ^ TextLib::TimeToText(diffInt, True) ^ "$fff)";
			Message::SendBigMessage(_Player, "", 10, 3, CUIConfig::EUISound::TiePoint, 0);
		} else {
			diffIntText = " ($f66+" ^ TextLib::TimeToText(diffInt, True) ^ "$fff)";
		}
	}
	
	
	
	G_CheckpointNext[_Player.Id] += 1;	
	
	Message::SendStatusMessage(_Player, "Time - [Checkpoint] : " ^ TextLib::TimeToText(Now - G_StartsTime[_Player.Id], True) ^ diffText ^ " - [" ^ TextLib::TimeToText(CheckpointsIntTimes[G_CheckpointNext[_Player.Id] - 1],True) ^ "]" ^ diffIntText, 5000, 3, CUIConfig::EUISound::ScoreProgress, sound);
}

//When a player passes finish
Void FinishEvent(CSmPlayer _Player){	
	CheckpointManage(_Player);

	declare time = Now - G_StartsTime[_Player.Id];
	declare diffFinal = time - G_BestTimes[_Player.Id];
	
	declare Text diffFinalText;
	declare newRecord = False;
		
	G_PreviousTimes[_Player.Id] = time;
	
	//if first run
	if(G_Finish[_Player.Id] == 0){
		G_BestTimes[_Player.Id] = G_PreviousTimes[_Player.Id];
		diffFinalText = "";
	} else {
		//Check if best time
		if(diffFinal < 0){
			G_BestTimes[_Player.Id] = G_PreviousTimes[_Player.Id];
			newRecord = True;
			
			diffFinalText = " ($00f" ^ TextLib::TimeToText(diffFinal, True) ^ "$fff)";
		} else {
			diffFinalText = " ($f00+" ^ TextLib::TimeToText(diffFinal, True) ^ "$fff)";
		}
	}
	
	if(newRecord){
		Message::SendBigMessage(_Player, TextLib::TimeToText(Now - G_StartsTime[_Player.Id], True) ^ diffFinalText, 5000, 3, CUIConfig::EUISound::VictoryPoint, 0);
	} else {
		Message::SendBigMessage(_Player, TextLib::TimeToText(Now - G_StartsTime[_Player.Id], True) ^ diffFinalText, 5000, 3, CUIConfig::EUISound::EndMatch, 0);
	}
	UnspawnPlayer(_Player);
	G_Finished[_Player.Id] = True;
	G_Finish[_Player.Id] += 1;
	G_CheckpointNext[_Player.Id] = 0;
	Chrono::Stop(_Player.Id);
	Chrono::Reset(_Player.Id);
	
	declare UI <=> UIManager.GetUI(_Player);
	
	UI.SendNotice("Run completed.", CUIConfig::ENoticeLevel::Default, Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::Silence, 0);
}

Void UpdatePlayersObstacle(){
	//Players
	foreach(Player, AllPlayers){
		if(!Player.RequestsSpectate){
			if(!G_StartsTime.existskey(Player.Id)){
				Chrono::Create(Player.Id);
				G_StartsTime[Player.Id] = 0;
				G_Finished[Player.Id] = True;
				G_Finish[Player.Id] = 0;
				G_BestTimes[Player.Id] = 0;
				G_PreviousTimes[Player.Id] = 0;
				
				declare Integer[Integer] CheckpointsTimes for Player;
				
				CheckpointsTimes = Integer[Integer];
			}
				
			if(Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned){		
				OSpawnPlayer(Player);
				if(G_Finished[Player.Id]){
					G_CheckpointNext[Player.Id] = 1;			
					G_Respawns[Player.Id] = 0;
					G_Finished[Player.Id] = False;
					G_Started[Player.Id] = False;
				}
			}
			if(Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned && !G_Started[Player.Id]){
				G_Started[Player.Id] = True;
				G_StartsTime[Player.Id] = Now;
				Chrono::Start(Player.Id, 0);
			}

			if(Player.CapturedLandmark != Null){
				if(TextLib::SubText(Player.CapturedLandmark.Tag, 0, 4) == "Goal"){
					if(G_CheckpointNext[Player.Id] == G_CheckpointsCount){
						FinishEvent(Player);
					}
				}
				if(TextLib::SubText(Player.CapturedLandmark.Tag, 0, 10) == "Checkpoint"){
					ChangeWeapon(Player);
					if(Player.CapturedLandmark.Order == G_CheckpointNext[Player.Id]){
						if(G_CheckpointNext[Player.Id] == G_CheckpointsCount){
							FinishEvent(Player);
						} else {
							CheckpointEvent(Player);
						}
					}
				}
			}
		}
		if(Player.RequestsSpectate && !G_Finished[Player.Id]){
			G_Finished[Player.Id] = True;
			G_CheckpointNext[Player.Id] = 0;
			Chrono::Stop(Player.Id);
			Chrono::Reset(Player.Id);
			G_Started[Player.Id] = False;
		}
		UpdatePlayerInterface(Player);
	}
	
	//Events
	foreach(Event, PendingEvents){
		switch(Event.Type){
			case CSmModeEvent::EType::OnPlayerRequestRespawn : {
				OSRespawnPlayer(Event.Player);
			}
			case CSmModeEvent::EType::OnArmorEmpty : {
				Discard(Event);
				OSRespawnPlayer(Event.Victim);
			}
		}
	}
}

Void InitInterface(){
	G_DebugInfo = UIManager.UILayerCreate();
	UIManager.UIAll.UILayers.add(G_DebugInfo);
	G_DebugInfo.ManialinkPage = """
		<frame posn="-158 88 0">
					<label posn="0 0 1" halign="left" style="TextButtonNav" text="Obstacle Reborn Revision : {{{C_Revision}}}" />
					
		</frame>
	""";
}

Void InitObstacle(){

	// Set mode options
	UseClans = False;
	UseAllies = False;
	UsePvPCollisions = False;
	UsePvPWeapons = False;
	UseSameWallJump = True;
	
	G_CheckpointsCount = 0;
	
	declare CSmMapLandmark[] ChecksRaw;
	
	ChecksRaw.clear();
	
	//Colors
	foreach(Base, MapBases){
		Base.Clan = 1;
		Base.IsActive = True;
	}
	
	//Get Spawns
	foreach(Spawn, MapLandmarks_PlayerSpawn){
		if(TextLib::SubText(Spawn.Tag, 0, 5) == "Spawn"){
			G_MainSpawn <=> Spawn;
		}
	}
	
	//Get checkpoint count
	foreach(Checkpoint, MapLandmarks_Gauge){	
		if(TextLib::SubText(Checkpoint.Tag, 0, 10) == "Checkpoint"){
			ChecksRaw.add(Checkpoint);
			G_CheckpointsCount += 1;
		}
	}
	
	//Reorganise
	for(i, 1, G_CheckpointsCount){
		declare CSmMapLandmark nextCheck;
	
		foreach(CurCheck, ChecksRaw){
			//First one
			if(nextCheck == Null){
				if(TextLib::SubText(CurCheck.Tag, 0, 10) == "Checkpoint"){
					nextCheck <=> CurCheck;
				}
			} else {
				if(CurCheck.Order < nextCheck.Order && TextLib::SubText(CurCheck.Tag, 0, 10) == "Checkpoint"){
					nextCheck <=> CurCheck;
				}
			}
		}
		
		G_Checkpoints[i] <=> nextCheck;
		declare removed = ChecksRaw.remove(nextCheck);
	}
	
	//Add goal retro compatibility
	if(Map.MapType != "ObstacleRebornArena"){
		foreach(FinishFind, MapLandmarks_Gauge){
			if(FinishFind.Tag == "Goal"){
				G_CheckpointsCount += 1;
				G_Checkpoints[G_CheckpointsCount] <=> FinishFind;
			}
		}
	}
}

//Clear stuff
Void Clear(){
	foreach(Player, Players){
		declare UI <=> UIManager.GetUI(Player);
		
		UI.ManialinkPage = "";
	}
}