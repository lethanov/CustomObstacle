/**
 *	Obstacle Reborn mode
 *  Authors : kana & lethan
 *  Original author : steeffeen
 */

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const CompatibleMapTypes  "ObstacleArena, ObstacleTitleArena, ObstacleRebornArena"
#Const Version             "21"
#Const ScriptName          "ObstacleReborn.Script.txt"

#Include "Libs/Nadeo/Settings.Script.txt" as Settings
#Include "TextLib" as TextLib
#Include "MathLib" as MathLib
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Layers.Script.txt" as Layers
#Include "Libs/Nadeo/Json.Script.txt" as Json
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/Lethan/ObstacleManialinks.Script.txt" as Manialinks
#Include "Libs/Lethan/ObstaclePlayerManager.Script.txt" as PM

declare Text G_GamePhase;

declare CSmMapLandmark G_MainSpawn;
declare CSmMapLandmark[Integer] G_Checkpoints;

declare Integer G_CheckpointsCount;

declare CUILayer G_ScoresTable;
declare CUILayer G_UIEventManager;


***StartMap***
***
declare ModeName = "Obstacle Reborn";
declare Rules = """
Authors : Kana & Lethan
Original Author : Steeffeen

- Finish the $<$88fobstacle course$> as fast as possible.
- To validate a race you must touch the finish after going through all the $<$88fcheckpoints$>.
- You can start over and improve your time as often as you want.
""";

SpawnScreen::ResetRulesSection();
SpawnScreen::AddSubsection(_("Obstacle Reborn - Informations"), Rules, 20.);
SpawnScreen::CreatePrettyRules(ModeName);
ModeStatusMessage = Rules;

SpawnScreen::CreateMapInfo();
//Users_DestroyAllFakes();
//Users_SetNbFakeUsers(5,0);
InitObstacle();
***

***PlayLoop***
***
Message::Loop();
if(G_GamePhase == "verify"){
	if(!VerifyMap()){
		Message::SendStatusMessage("Please inform the map author : $z" ^ Map.AuthorNickName ^ " $z(" ^ Map.AuthorLogin ^ ")", 5000, 3, CUIConfig::EUISound::Silence, 0);
		Message::SendBigMessage("The map is corrupted / out of date", 5000, 3, CUIConfig::EUISound::EndRound, 0);
		sleep(8000);
		G_GamePhase = "skip";
		MatchEndRequested = True;
	} else {
		G_GamePhase = "init";
	}
}
if(G_GamePhase == "init"){
	declare Text authorMsg = "Author : $z" ^ Map.AuthorNickName ^ " $z(" ^ Map.AuthorLogin ^ ")";
	Message::SendStatusMessage(authorMsg, 5000, 3, CUIConfig::EUISound::Silence, 0);
	Message::SendBigMessage(MapName, 5000, 3, CUIConfig::EUISound::EndRound, 0);
	
	sleep(2000);
	
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	StartTime = Now;
	EndTime = -1;
	
	G_GamePhase = "play";
}
if(G_GamePhase == "play"){
	ObstacleMain();
}
***

***OnNewPlayer***
***
PM::Init(Player.Id, G_Checkpoints);

declare UI <=> UIManager.GetUI(Player);
UI.OverlayHideGauges = True;
***

***OnNewSpectator***
***
PM::Init(Spectator.Id, G_Checkpoints);

declare UI <=> UIManager.GetUI(Spectator);
UI.OverlayHideGauges = True;
***



***EndMap***
***
UIManager.UILayerDestroyAll();
XmlRpc.SendCallback("endMap1", GetRankings());
***

// ---------------------------------- //
// Functions
// ---------------------------------- //
//XmlCallBack
Void SendXmlRpcCallback(Text _CallbackName, CSmPlayer _Player, Integer _RunTime, Ident _CheckpointId) {
	if (_Player == Null || _Player.IsFakePlayer || _Player.Score == Null || _CallbackName == "" || _RunTime <= 0) return;
	declare Respawns for _Player = 0;
	declare JSON = "";
	
	// Player information
	JSON ^= Json::StringifyMinimal("Player", _Player, "")^",";
	
	// Run information
	JSON ^= """ "Run":{""";
	JSON ^= Json::Stringify("Time", _RunTime)^",";
	JSON ^= Json::Stringify("RespawnCount", Respawns)^",";
	
	declare CheckpointsTimeLast for _Player.Score = Integer[Ident];
	JSON ^= Json::Stringify("CheckpointIndex", CheckpointsTimeLast.count-1)^",";
	JSON ^= """ "CheckpointId":"{{{_CheckpointId}}}"}""";
	
	XmlRpc.SendCallback(_CallbackName, Json::Enfold(JSON));
}

//Send Notice
Void SendNotice(CSmPlayer _Player, Text _Message){
	declare UI <=> UIManager.GetUI(_Player);
	UI.SendNotice(_Message, CUIConfig::ENoticeLevel::Default, Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::Silence, 0);
}

Void SpawnStartPlayer(Ident _PlayerId){
	if(Players.existskey(_PlayerId)){
		declare _Player = Players[_PlayerId];

		_Player.ArmorMax = 100;

		SpawnPlayer(_Player, 0, 100, G_MainSpawn.PlayerSpawn, Now);
		SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 4);
		SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, 4);

		PM::RespawnPlayer(_Player.Id);
	}
}

Void ManageRespawnPlayer(Ident _PlayerId, Boolean _CustomKey){
	if(Players.existskey(_PlayerId)){
		declare _Player = Players[_PlayerId];
		declare UI <=> UIManager.GetUI(_Player);
		declare netread Boolean RespawnAtStart for UI;

		//Full restart
		if(_CustomKey){
			SpawnStartPlayer(_Player.Id);
		} else {
			if(!RespawnAtStart){
				if(PM::GetCheckpointObjective(_Player.Id) > 1){
					PM::RespawnPlayerAtLastCP(_Player.Id);
				} else {
					SpawnStartPlayer(_Player.Id);
				}
			} else {
				SpawnStartPlayer(_Player.Id);
			}
		}
	}
}

Void CheckpointEvent(Ident _PlayerId){
	if(Players.existskey(_PlayerId)){
		PM::DoCheckpointProgress(_PlayerId);

		declare _Player = Players[_PlayerId];

		declare Text message;
		declare sound = 1;

		declare Text diffPersonnal;
		declare Text diffBest;

		if(PM::IsNotHisFirstRun(_PlayerId)){
			if(PM::GetLastCPDiff(_PlayerId) < 0){
				diffPersonnal = " $99f" ^ TextLib::TimeToText(PM::GetLastCPDiff(_PlayerId), True);
				sound = 3;
			} else {
				diffPersonnal = " $f99+" ^ TextLib::TimeToText(PM::GetLastCPDiff(_PlayerId), True);
				sound = 0;
			}
		}

		if(PM::IsMapFinishedBySomeone()){
			if(PM::GetLastCPDiffBest(_PlayerId) < 0){
				diffBest = " $ff0" ^ TextLib::TimeToText(PM::GetLastCPDiffBest(_PlayerId), True);
				Message::SendBigMessage(_Player, "", 10, 3, CUIConfig::EUISound::Record, 0);
			} else {
				diffBest = " $999+" ^ TextLib::TimeToText(PM::GetLastCPDiffBest(_PlayerId), True);
			}
		}
		message = "Time : " ^ TextLib::TimeToText(PM::GetTime(_Player.Id), True) ^ diffPersonnal ^ diffBest;
		

		Message::SendStatusMessage(_Player, message, 5000, 3, CUIConfig::EUISound::ScoreProgress, sound);
	}
}

Void FinishEvent(Ident _PlayerId){
	if(Players.existskey(_PlayerId)){
		PM::DoCheckpointProgress(_PlayerId);
		PM::CalculateTime(_PlayerId);
		
		declare _Player = Players[_PlayerId];

		declare Text message;

		declare Text diffPersonnal;
		declare Text diffBest;

		if(PM::IsNotHisFirstRun(_PlayerId)){
			if(PM::GetBestTimeDiff(_Player.Id) < 0){
				diffPersonnal = " $00f" ^ TextLib::TimeToText(PM::GetBestTimeDiff(_Player.Id), True);
				Message::SendBigMessage(_Player, "", 10, 3, CUIConfig::EUISound::VictoryPoint, 0);
			} else {
				diffPersonnal = " $f00+" ^ TextLib::TimeToText(PM::GetBestTimeDiff(_Player.Id), True);
			}
		}

		if(PM::IsMapFinishedBySomeone()){
			if(PM::GetBestTimeDiffAll(_PlayerId) < 0){
				diffBest = " $ff0" ^ TextLib::TimeToText(PM::GetBestTimeDiffAll(_PlayerId), True);
				Message::SendBigMessage(_Player, "", 10, 3, CUIConfig::EUISound::Record, 0);
			} else {
				diffBest = " $999+" ^ TextLib::TimeToText(PM::GetBestTimeDiffAll(_PlayerId), True);
			}
		}

		message = "Final Time : " ^ TextLib::TimeToText(PM::GetLastTime(_Player.Id), True) ^ diffPersonnal ^ diffBest;
		
		
		Message::SendStatusMessage(_Player, message, 5000, 3, CUIConfig::EUISound::EndRound, 0);

		SendXmlRpcCallback("OnFinish", _Player, PM::GetLastTime(_Player.Id), G_Checkpoints[G_Checkpoints.count - 1].Id);

		PM::RaceFinish(_PlayerId);
		
		UnspawnPlayer(_Player);
	}
}

Void ObstacleMain(){
	//Players
	foreach(Player, AllPlayers){
		PM::Update(Player.Id);
		if(!Player.RequestsSpectate){
			if(Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned){
				SpawnStartPlayer(Player.Id);
			}
			if(Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned && !PM::IsRaceStarted(Player.Id)){
				PM::RaceStart(Player.Id);
			}

			if(Player.CapturedLandmark != Null){
				if(TextLib::SubText(Player.CapturedLandmark.Tag, 0, 4) == "Goal"){
					if(PM::GetCheckpointObjective(Player.Id) == G_CheckpointsCount){
						FinishEvent(Player.Id);
					}
				}
				if(TextLib::SubText(Player.CapturedLandmark.Tag, 0, 10) == "Checkpoint"){
					if(Player.CapturedLandmark.Order == G_Checkpoints[PM::GetCheckpointObjective(Player.Id)].Order){
						if(PM::GetCheckpointObjective(Player.Id) == G_CheckpointsCount){
							FinishEvent(Player.Id);
						} else {
							CheckpointEvent(Player.Id);
						}
					}
				}
			}


			//Handle stamina if illimited;
			declare Boolean StaminaUnlimited for Player;

			//Respawn CP or Respawn
			declare UI <=> UIManager.GetUI(Player);
			declare LastCustomKeyTime for Player = 0;
			declare netread CustomKeyTime for UI = 0;
			
			if (CustomKeyTime > LastCustomKeyTime) {
				ManageRespawnPlayer(Player.Id, True);
				LastCustomKeyTime = CustomKeyTime;
			}

			if(StaminaUnlimited){
				Player.Stamina = 3600;
			}
		}
	}

	//Managing events
	foreach(Event, PendingEvents){
		switch(Event.Type){
			case CSmModeEvent::EType::OnShoot : {
				PassOn(Event);
				PM::OnShoot(Event.Shooter.Id);
			}
			case CSmModeEvent::EType::OnPlayerRequestRespawn : {
				Discard(Event);
				ManageRespawnPlayer(Event.Player.Id, False);
			}
			case CSmModeEvent::EType::OnArmorEmpty : {
				Discard(Event);
				ManageRespawnPlayer(Event.Victim.Id, False);
			}
		}
	}

	//Each player

}

//Verify map
Boolean VerifyMap(){
	declare Boolean clean;
	clean = True;

	if(TextLib::SubText(Map.MapType, 11, 19) == "ObstacleRebornArena"){
		if(MapLandmarks_PlayerSpawn.count != 1){
			clean = False;
		}
	}

	declare goalExists = False;
	
	if(TextLib::SubText(Map.MapType, 11, 19) != "ObstacleRebornArena"){
		foreach(FinishFind, MapLandmarks_Gauge){
			if(FinishFind.Tag == "Goal"){
				goalExists = True;
			}
		}
		if(!goalExists){
			clean = False;
		}
	} else {
		goalExists = True;
	}

	

	declare Boolean[Integer] orders;

	foreach(Test, MapLandmarks_Gauge){
		if(orders.existskey(Test.Order)){
			clean = False;
		} else {
			orders[Test.Order] = True;
		}
	}

	return clean;
}

//Init obstacle
Void InitObstacle(){
	
	// Set mode options
	UseClans = False;
	UsePvPCollisions = False;
	UsePvPWeapons = False;
	UseSameWallJump = True;
	MB_Sleep(1);
	G_GamePhase = "verify";

	//Colors
	foreach(Base, MapBases){
		Base.Clan = 1;
		Base.IsActive = True;
	}

	Teams[0].ColorPrimary = <MathLib::Rand(0.0, 1.0), MathLib::Rand(0.0, 1.0), MathLib::Rand(0.0, 1.0)>;
	
	SM::SetupDefaultVisibility();

	//Purge other manialinks
	UIManager.UIAll.ScoreTableOnlyManialink = True;
	UIManager.UIAll.AltMenuNoCustomScores = False;
	UIManager.UIAll.OverlayHideMapInfo = True;
	UIManager.UIAll.OverlayHideCountdown = True;

	//Create Score Table
	G_ScoresTable = UIManager.UILayerCreate();
	G_ScoresTable.Type = CUILayer::EUILayerType::ScoresTable;
	G_ScoresTable.ManialinkPage = Manialinks::CreateScoresTable();
	UIManager.UIAll.UILayers.add(G_ScoresTable);

	//Create UIEventManager
	G_UIEventManager = UIManager.UILayerCreate();
	G_UIEventManager.ManialinkPage = Manialinks::CreateUIEventManager();
	UIManager.UIAll.UILayers.add(G_UIEventManager);

	//Get Spawns
	foreach(Spawn, MapLandmarks_PlayerSpawn){
		if(TextLib::SubText(Spawn.Tag, 0, 5) == "Spawn"){
			G_MainSpawn <=> Spawn;
		}
	}
	

	//Manage Checkpoints and goal
	declare CSmMapLandmark[] ChecksRaw;
	
	ChecksRaw.clear();
	G_Checkpoints = CSmMapLandmark[Integer];
	G_CheckpointsCount = 0;

	//Get checkpoint count
	foreach(Checkpoint, MapLandmarks_Gauge){	
		if(TextLib::SubText(Checkpoint.Tag, 0, 10) == "Checkpoint"){
			ChecksRaw.add(Checkpoint);
			G_CheckpointsCount += 1;
		}
	}
	
	//Reorganise
	for(i, 1, G_CheckpointsCount){
		declare CSmMapLandmark nextCheck;
	
		foreach(CurCheck, ChecksRaw){
			//First one
			if(nextCheck == Null){
				if(TextLib::SubText(CurCheck.Tag, 0, 10) == "Checkpoint"){
					nextCheck <=> CurCheck;
				}
			} else {
				if(CurCheck.Order < nextCheck.Order && TextLib::SubText(CurCheck.Tag, 0, 10) == "Checkpoint"){
					nextCheck <=> CurCheck;
				}
			}
		}
		
		G_Checkpoints[i] <=> nextCheck;
		declare removed = ChecksRaw.remove(nextCheck);
	}
	
	//Add goal retro compatibility
	if(TextLib::SubText(Map.MapType, 11, 19) != "ObstacleRebornArena"){
		foreach(FinishFind, MapLandmarks_Gauge){
			if(FinishFind.Tag == "Goal"){
				G_CheckpointsCount += 1;
				G_Checkpoints[G_CheckpointsCount] <=> FinishFind;
			}
		}
	}

	declare netwrite Integer Net_CheckpointsCount for Teams[0];
	declare netwrite Integer Net_PlayersCount for Teams[0];

	Net_CheckpointsCount = G_CheckpointsCount;
	Net_PlayersCount = AllPlayers.count;

	PM::Start();
}

Text GetRankings() {
	declare PlayerList = "";
	foreach (Player in AllPlayers) {
		PlayerList ^= Player.Login ^ ":" ^ PM::GetBestTime(Player.Id);
	}
	return PlayerList;
}