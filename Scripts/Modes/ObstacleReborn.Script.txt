/**
 *	Obstacle Reborn mode
 *  Authors : kana & lethan
 *  Original author : steeffeen
 */

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const CompatibleMapTypes  "ObstacleRebornArena, ObstacleTitleArena, ObstacleArena"
#Const Version             "17"
#Const ScriptName          "ObstacleReborn.Script.txt"

#Include "Libs/Nadeo/Settings.Script.txt" as Settings
#Include "TextLib" as TextLib
#Include "MathLib" as MathLib
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Json.Script.txt" as Json
#Include "Libs/Nadeo/Layers.Script.txt" as Layers
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/Lethan/ChronoObs.Script.txt" as Chrono

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_Revision 17

// ---------------------------------- //
// Globales
// ---------------------------------- //
declare CSmMapLandmark G_MainSpawn;
declare CSmMapLandmark[Integer] G_Checkpoints;

declare Integer G_CheckpointsCount;
declare Boolean G_FinishAny;

declare Integer[Ident] G_StartsTime;
declare Integer[Ident] G_PreviousTimes;
declare Integer[Ident] G_BestTimes;

declare Integer[Integer] G_BestChecks;
declare Integer[Integer] G_BestChecksInt;

declare Integer[Ident] G_CheckpointNext;
declare Integer[Ident] G_Respawns;
declare Integer[Ident] G_Finish;

declare Boolean[Ident] G_Stamina;

declare CUILayer G_UIEventManager;
declare CUILayer G_ScoresTable;
declare CUILayer G_OptionsMenu;

declare Text G_GamePhase;

***Rules***
***
declare ModeName = "Obstacle Reborn";
declare ModeRules = """
Authors : Kana & Lethan
Original Author : Steeffeen

- Finish the $<$88fobstacle course$> as fast as possible.
- To validate a race you must touch the finish after going through all the $<$88fcheckpoints$>.
- You can start over and improve your time as often as you want.
""";

SpawnScreen::ResetRulesSection();
SpawnScreen::AddSubsection(_("Obstacle Reborn - Informations"), ModeRules, 20.);
SpawnScreen::CreatePrettyRules(ModeName);
ModeStatusMessage = """
- Finish the $<$88fobstacle course$> as fast as possible.
- To validate a race you must touch the finish after going through all the $<$88fcheckpoints$>.
- You can start over and improve your time as often as you want.
""";
***

***StartServer***
***

SpawnScreen::CreateMapInfo();

ST2::Unload();
---Rules---

InitInterface();
***

***StartMap***
***
G_GamePhase = "init";
//declare test = Users_CreateFake("Oiseau", 0);
//Users_DestroyAllFakes();
//Users_SetNbFakeUsers(20,0);
InitObstacle();

MB_Sleep(1); //Score sort

sleep(1000);
***

***PlayLoop***
***
if(G_GamePhase == "init"){
	declare Text authorMsg = "Author : $z" ^ Map.AuthorNickName ^ " $z(" ^ Map.AuthorLogin ^ ")";
	Message::SendStatusMessage(authorMsg, 5000, 3, CUIConfig::EUISound::Silence, 0);
	Message::SendBigMessage(MapName, 5000, 3, CUIConfig::EUISound::EndRound, 0);
	
	sleep(2000);
	
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	StartTime = Now;
	EndTime = -1;
	
	G_FinishAny = False;
	G_ScoresTable.ManialinkPage = CreateScoresTable();
	G_GamePhase = "play";
}

if(G_GamePhase == "play"){
	UpdatePlayersObstacle();
}
Message::Loop();

***

***OnNewPlayer***
***
Chrono::Create(Player.Id);
G_StartsTime[Player.Id] = 0;
G_Stamina[Player.Id] = False;
if(!G_BestTimes.existskey(Player.Id)){
	G_Finish[Player.Id] = 0;
	G_BestTimes[Player.Id] = -1;
	G_PreviousTimes[Player.Id] = 0;
	declare Integer[Integer] CheckpointsTimes for Player;
	CheckpointsTimes = Integer[Integer];
}
UpdateScoresTable();
***

***EndMap***
***
foreach(Player, Players){
	declare UI <=> UIManager.GetUI(Player);
	G_BestTimes[Player.Id] = -1;
	G_PreviousTimes[Player.Id] = 0;
	UI.ManialinkPage = "";
	UI.MarkersXML = "";
	Chrono::Stop(Player.Id);
	Chrono::Reset(Player.Id);
}
***


// ---------------------------------- //
// Functions
// ---------------------------------- //

Void SendXmlRpcCallback(Text _CallbackName, CSmPlayer _Player, Integer _RunTime, Ident _CheckpointId) {
	if (_Player == Null || _Player.IsFakePlayer || _Player.Score == Null || _CallbackName == "" || _RunTime <= 0) return;
	declare RespawnCount for _Player = 0;
	declare JSON = "";
	
	// Player information
	JSON ^= Json::StringifyMinimal("Player", _Player, "")^",";
	
	// Run information
	JSON ^= """ "Run":{""";
	JSON ^= Json::Stringify("Time", _RunTime)^",";
	JSON ^= Json::Stringify("RespawnCount", RespawnCount)^",";
	
	declare CheckpointsTimeLast for _Player.Score = Integer[Ident];
	JSON ^= Json::Stringify("CheckpointIndex", CheckpointsTimeLast.count-1)^",";
	JSON ^= """ "CheckpointId":"{{{_CheckpointId}}}"}""";
	
	XmlRpc.SendCallback(_CallbackName, Json::Enfold(JSON));
}

//Send Notice
Void SendNotice(CSmPlayer _Player, Text _Message){
	declare UI <=> UIManager.GetUI(_Player);
	UI.SendNotice(_Message, CUIConfig::ENoticeLevel::Default, Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::Silence, 0);
}

//Change stamina
Void ChangeStamina(CSmPlayer _Player){
	if(_Player.CapturedLandmark != Null){
		declare AnchorDetails = TextLib::Split("|", _Player.CapturedLandmark.Tag);
		
		if(AnchorDetails[0] == "Checkpoint"){
			//Default
			if(AnchorDetails.count == 1){
				if(_Player.StaminaGain != 1.0 || G_Stamina[_Player.Id]){
					G_Stamina[_Player.Id] = False;
					_Player.StaminaGain = 1.0;
				}
			} else {
				if(TextLib::ToInteger(AnchorDetails[2]) == 2 && !G_Stamina[_Player.Id]){
					G_Stamina[_Player.Id] = True;
					SendNotice(_Player, "$afaInfinite stamina.");
				}
				if(TextLib::ToInteger(AnchorDetails[2]) == 1 && _Player.Stamina < 3600){
					SendNotice(_Player, "$aafStamina refilled.");
					_Player.Stamina = 3600;
					G_Stamina[_Player.Id] = False;
				}
				if(TextLib::ToInteger(AnchorDetails[2]) == 0 && G_Stamina[_Player.Id]){
					G_Stamina[_Player.Id] = False;
				}
				if(TextLib::ToInteger(AnchorDetails[3]) == 0 && _Player.StaminaGain != 0.0){
					_Player.StaminaGain = 0.0;
					SendNotice(_Player, "$aafNo Stamina gain.");
				}
				if(TextLib::ToInteger(AnchorDetails[3]) == 1 && _Player.StaminaGain != 1.0){
					_Player.StaminaGain = 1.0;
					SendNotice(_Player, "$aafStamina gain.");
				}
				
			}
		}
	} else {
		_Player.StaminaGain = 1.0;
		G_Stamina[_Player.Id] = False;
	}
}

//Change weapon on check or spawn
Void ChangeAmmo(CSmPlayer _Player){
	//Oncheckpoint
	if(_Player.CapturedLandmark != Null){
		declare AnchorDetails = TextLib::Split("|", _Player.CapturedLandmark.Tag);
		
		if(AnchorDetails[0] == "Checkpoint"){
			//Default
			if(AnchorDetails.count == 1){
				if(GetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket) != 4){
					SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, 4);
					SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 4);
					_Player.AmmoGain = 1.0;
					SendNotice(_Player, "Weapon ammo set to normal.");
				}
			} else {
				if(TextLib::ToInteger(AnchorDetails[1]) == 11){ //Unlimited ammo !
					if(GetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket) != 20){
						SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, 20);
						SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 20);
						_Player.AmmoGain = 10.0;
						SendNotice(_Player, "Weapon ammo set to unlimited.");
					}
				} else {
					if(GetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket) != TextLib::ToInteger(AnchorDetails[1])){
						SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, TextLib::ToInteger(AnchorDetails[1]));
						SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, TextLib::ToInteger(AnchorDetails[1]));
						_Player.AmmoGain = 1.0;
						SendNotice(_Player, "Weapon ammo set to " ^ TextLib::ToInteger(AnchorDetails[1]) ^ ".");
					}
				}
			}
		} else if(TextLib::SubText(_Player.CapturedLandmark.Tag, 0, 10) == "Checkpoint"){
			if(TextLib::SubText(_Player.CapturedLandmark.Tag, 10, 5) == "Type2" && GetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket) != 10){
				SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, 10);
				SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 10);
				_Player.AmmoGain = 10.0;
				SendNotice(_Player, "Weapon ammo set to unlimited.");
			} else if(TextLib::SubText(_Player.CapturedLandmark.Tag, 10, 5) == "Type1" && GetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket) != 0){
				SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, 0);
				SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
				_Player.AmmoGain = 0.0;
				SendNotice(_Player, "No ammo.");
			}
		} else {
			SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, 4);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 4);
			_Player.AmmoGain = 1.0;
			SendNotice(_Player, "Weapon ammo set to normal.");
		}
	} else {
	//On Spawn
		if(TextLib::SubText(G_MainSpawn.Tag, 5, 5) == "Type2" && GetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket) != 10){
			SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, 10);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 10);
			_Player.AmmoGain = 10.0;
			SendNotice(_Player, "Weapon ammo set to unlimited.");
		} else if(TextLib::SubText(G_MainSpawn.Tag, 5, 5) == "Type1" && GetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket) != 0){
			SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
			_Player.AmmoGain = 0.0;
			SendNotice(_Player, "No ammo.");
		} else {
			SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, 4);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 4);
			_Player.AmmoGain = 1.0;
		}
	}
}

//Spawn player
Void OSpawnPlayer(CSmPlayer _Player){
	_Player.ArmorMax = 100;
	
	SpawnPlayer(_Player, 0, 100, G_MainSpawn.PlayerSpawn, Now);
	ChangeStamina(_Player);
	ChangeAmmo(_Player);
}

//Restart player
Void RestartPlayer(CSmPlayer _Player){

	declare UI <=> UIManager.GetUI(_Player);
	declare netread RespawnAtStart for UI = False;

	if(!RespawnAtStart){
		if(G_CheckpointNext[_Player.Id] > 1){
			
			
			RespawnPlayer(_Player, G_Checkpoints[G_CheckpointNext[_Player.Id] - 1]);	
			G_Respawns[_Player.Id] += 1;
		} else {

			OSpawnPlayer(_Player);
			Chrono::Stop(_Player.Id);
			G_CheckpointNext[_Player.Id] = 0;
			Chrono::Reset(_Player.Id);
			G_StartsTime[_Player.Id] = 0;
			G_Respawns[_Player.Id] = 0;
		}
		return;
	}
	OSpawnPlayer(_Player);
	Chrono::Stop(_Player.Id);
	G_CheckpointNext[_Player.Id] = 0;
	Chrono::Reset(_Player.Id);
	G_StartsTime[_Player.Id] = 0;
	G_Respawns[_Player.Id] = 0;
}

//Update Player Manialink Interface
Void UpdatePlayerInterface(CSmPlayer _Player){
	declare UI <=> UIManager.GetUI(_Player); //Get UI for player
	declare cpNext = G_CheckpointNext[_Player.Id]; //Get next checkpoint
		
	declare netread Boolean SwitchFullHud for UI;
	declare netread Boolean SwitchExtraHud for UI;
	
	declare netread RespawnAtStart for UI = False;

	//Force spectate someone
	declare netread Text SpecTarget for UI;
	declare CSmPlayer SpecPlayer for UI;

	SpecPlayer = Null;

	if(SpecTarget != "" && SpecTarget != _Player.Login){
		//Search for the player wanted
		foreach(OtherPlayer, Players){
			if(OtherPlayer.Login == SpecTarget){
				SpecPlayer = OtherPlayer;
			}
		}
	}

	UI.SpectatorForcedTarget = NullId;
	UI.SpectatorAutoTarget = NullId;
	UI.ForceSpectator = False;

	if(SpecPlayer != Null && Players.exists(SpecPlayer) && !SpecPlayer.RequestsSpectate){
		UI.SpectatorForcedTarget = SpecPlayer.Id;
		UI.SpectatorAutoTarget = SpecPlayer.Id;
		UI.ForceSpectator = True;
	}

	UI.MarkersXML = "";
	UI.ManialinkPage = "";
	
	if(!_Player.RequestsSpectate){
		if(cpNext != 0){
			if(cpNext != G_CheckpointsCount){
				UI.MarkersXML = """<marker label="Checkpoint {{{cpNext}}}" pos="{{{G_Checkpoints[cpNext].Position.X}}} {{{G_Checkpoints[cpNext].Position.Y + 2}}} {{{G_Checkpoints[cpNext].Position.Z}}}" />""";
			} else {
				UI.MarkersXML = """<marker label="Goal" pos="{{{G_Checkpoints[cpNext].Position.X}}} {{{G_Checkpoints[cpNext].Position.Y + 2}}} {{{G_Checkpoints[cpNext].Position.Z}}}" />""";
			}
		}
		
		declare progress = G_CheckpointNext[_Player.Id] - 1;
		
		declare Text BestTheoreticalText;
		declare Text BestTimePersonal;
		declare Text BestAllTheoreticalText;
		declare Text PreviousTimePersonal;
		declare Text NextCheckPersonal;
		declare Text PreviousCheckPersonal;
		
		declare Integer[Integer] CheckpointsTimes for _Player;
		declare Integer[Integer] CheckpointsIntTimes for _Player;
			
		declare Integer[Integer] CheckpointsBestTimes for _Player;
		declare Integer[Integer] CheckpointsBestIntTimes for _Player;
		
		declare BestTheoretical = 0;
		foreach(CPTime, CheckpointsBestIntTimes){
			BestTheoretical += CPTime;
		}
		
		declare BestAllTheoretical = 0;
		foreach(CPTimeAll, G_BestChecksInt){
			BestAllTheoretical += CPTimeAll;
		}
		
		if(G_FinishAny){
			BestAllTheoreticalText = TextLib::TimeToText(BestAllTheoretical, True);
		} else {
			BestAllTheoreticalText = "--:--,--";
		}
		
		if(G_Finish[_Player.Id] != 0){
			BestTheoreticalText = TextLib::TimeToText(BestTheoretical, True);
		} else {
			BestTheoreticalText = "--:--,--";
		}
		
		if(G_Finish[_Player.Id] != 0 && G_CheckpointNext[_Player.Id] != 0 && CheckpointsTimes[G_CheckpointNext[_Player.Id]] != 0){
			if(CheckpointsBestTimes[G_CheckpointNext[_Player.Id]] - G_BestChecks[G_CheckpointNext[_Player.Id]] > 0){
				NextCheckPersonal = TextLib::TimeToText(CheckpointsBestTimes[G_CheckpointNext[_Player.Id]], True) ^ " $f66[+" ^ TextLib::TimeToText(CheckpointsBestTimes[G_CheckpointNext[_Player.Id]] - G_BestChecks[G_CheckpointNext[_Player.Id]], True) ^ "]";	
			} else {
				NextCheckPersonal = TextLib::TimeToText(CheckpointsBestTimes[G_CheckpointNext[_Player.Id]], True);
			}
		} else {
			NextCheckPersonal = "--:--,--";
		}
		
		if(G_CheckpointNext[_Player.Id] > 1){
			PreviousCheckPersonal = TextLib::TimeToText(CheckpointsTimes[G_CheckpointNext[_Player.Id] - 1], True);
			if(G_Finish[_Player.Id] != 0){
				declare diff = CheckpointsTimes[G_CheckpointNext[_Player.Id] - 1] - CheckpointsBestTimes[G_CheckpointNext[_Player.Id] - 1];
				if(diff > 0){
					PreviousCheckPersonal = "$f66(+" ^ TextLib::TimeToText(diff, True) ^ ")";	
				} else {
					PreviousCheckPersonal = "$66f" ^ TextLib::TimeToText(CheckpointsBestTimes[G_CheckpointNext[_Player.Id] - 1], True);
				}
			}
			if(CheckpointsBestTimes[G_CheckpointNext[_Player.Id] - 1] - G_BestChecks[G_CheckpointNext[_Player.Id] - 1] > 0){
				PreviousCheckPersonal ^= " $f66[+" ^ TextLib::TimeToText(CheckpointsTimes[G_CheckpointNext[_Player.Id] - 1] - G_BestChecks[G_CheckpointNext[_Player.Id] - 1], True) ^ "]";
			}
		} else {
			PreviousCheckPersonal = "--:--,--";
		}
		
		if(G_PreviousTimes[_Player.Id] != 0){
			PreviousTimePersonal = TextLib::TimeToText(G_PreviousTimes[_Player.Id], True);
		} else {
			PreviousTimePersonal = "--:--.--";	
		}
		
		if(G_BestTimes[_Player.Id] != -1){
			BestTimePersonal = TextLib::TimeToText(G_BestTimes[_Player.Id], True);
		} else {
			BestTimePersonal = "--:--.--";	
		}
		

		if(progress < 0) progress = 0;
		
		//Show Full Hud
		if(SwitchFullHud){
			UI.ManialinkPage =	
			"""
			<label posn="-48 -76 0" halign="center" valign="center" style="TextButtonMedium" text="$sProgress : {{{progress}}}/{{{G_CheckpointsCount}}}"/>
			
			
			<label posn="80 -82 0" sizen="19 5" text="$fff{{{MathLib::FloorInteger(_Player.Speed*1.5)}}}" style="TextRaceChrono" halign="center" valign="center"/>
			
			<frame posn="0 -12 0">
			
			
			<quad posn="162 -68" sizen="48 14" halign="right" valign="center" bgcolor="00000055"/>
			<label posn="128 -65 0" halign="center" valign="center" sizen="20 5" text="$sBest time" textsize="1" style="TextButtonMedium"/>
			<label posn="128 -71 0" halign="center" valign="center" sizen="20 5" text="$sPrevious" textsize="1" style="TextButtonMedium"/>
			<label posn="148 -65 0" sizen="19 5" text="$C33{{{BestTimePersonal}}}" style="TextRaceChrono" textsize="3" halign="center" valign="center"/>
			<label posn="148 -71 0" sizen="19 5" text="$C30{{{PreviousTimePersonal}}}" style="TextRaceChrono" textsize="3" halign="center" valign="center"/>
			
			<quad posn="162 -53" sizen="62 10" halign="right" valign="center" bgcolor="00000055"/>
			<label posn="121 -53 0" sizen="34 6" style="TextButtonMedium" text="$sBest Theoretical" id="time" halign="center" valign="center"/>			
			<label posn="157 -53 0" sizen="42 5" text="$66f{{{BestTheoreticalText}}}" style="TextRaceChrono" textsize="4" halign="right" valign="center"/>
			
			<quad posn="162 -40" sizen="62 10" halign="right" valign="center" bgcolor="00000055"/>
			<label posn="121 -40 0" sizen="34 6" style="TextButtonMedium" text="$s(All) Best Theoretical" id="time" halign="center" valign="center"/>			
			<label posn="157 -40 0" sizen="42 5" text="$33f{{{BestAllTheoreticalText}}}" style="TextRaceChrono" textsize="4" halign="right" valign="center"/>
			</frame>			
			""";
			if(!RespawnAtStart){
				UI.ManialinkPage ^=	
				"""
				<label posn="50 -76 0" halign="center" valign="center" style="TextButtonMedium" textsize="1" text="$sRuns : {{{G_Finish[_Player.Id]}}} | Respawns : {{{G_Respawns[_Player.Id]}}}"/>
				""";
			} else {
				UI.ManialinkPage ^=	
				"""
				<label posn="50 -76 0" halign="center" valign="center" style="TextButtonMedium" textsize="1" text="$sRuns : {{{G_Finish[_Player.Id]}}} | $f00No respawn"/>
				""";
			}
		} else { //Show Minimal Hud
			UI.ManialinkPage =
			"""
			<label posn="-48 -76 0" halign="center" valign="center" style="TextButtonMedium" text="$s{{{progress}}}/{{{G_CheckpointsCount}}}"/>
			
			<label posn="80 -82 0" sizen="19 5" text="$fff{{{MathLib::FloorInteger(_Player.Speed*1.5)}}}" style="TextRaceChrono" halign="center" valign="center"/>
			
			<frame posn="0 -12 0">
			
			
			<quad posn="162 -68" sizen="24 14" halign="right" valign="center" bgcolor="00000055"/>
			
			<label posn="148 -65 0" sizen="19 5" text="$C33{{{BestTimePersonal}}}" style="TextRaceChrono" textsize="3" halign="center" valign="center"/>
			<label posn="148 -71 0" sizen="19 5" text="$C30{{{PreviousTimePersonal}}}" style="TextRaceChrono" textsize="3" halign="center" valign="center"/>
			
			<quad posn="162 -53" sizen="28 10" halign="right" valign="center" bgcolor="00000055"/>
		
			<label posn="157 -53 0" sizen="42 5" text="$66f{{{BestTheoreticalText}}}" style="TextRaceChrono" textsize="4" halign="right" valign="center"/>
			
			<quad posn="162 -40" sizen="28 10" halign="right" valign="center" bgcolor="00000055"/>
		
			<label posn="157 -40 0" sizen="42 5" text="$33f{{{BestAllTheoreticalText}}}" style="TextRaceChrono" textsize="4" halign="right" valign="center"/>
			</frame>
			""";
			if(!RespawnAtStart){
				UI.ManialinkPage ^=	
				"""
				<label posn="50 -76 0" halign="center" valign="center" style="TextButtonMedium" text="$s{{{G_Finish[_Player.Id]}}} | {{{G_Respawns[_Player.Id]}}}"/>
				""";
			} else {
				UI.ManialinkPage ^=	
				"""
				<label posn="50 -76 0" halign="center" valign="center" style="TextButtonMedium" text="$s{{{G_Finish[_Player.Id]}}}"/>
				""";
			}
		}

		if(SwitchExtraHud){
			UI.ManialinkPage ^=
			"""
			<quad posn="-40 -65" sizen="36 8" halign="center" valign="center" bgcolor="00000055"/>
			<quad posn="40 -65" sizen="36 8" halign="center" valign="center" bgcolor="00000055"/>
			<label posn="-50 -61 0" sizen="34 6" style="TextButtonMedium" text="$sPrevious" id="time" halign="center" valign="center"/>
			<label posn="30 -61 0" sizen="34 6" style="TextButtonMedium" text="$sNext" id="time" halign="center" valign="center"/>			
			<label posn="-40 -65 1" sizen="42 5" text="$f99{{{PreviousCheckPersonal}}}" style="TextRaceChrono" textsize="2" halign="center" valign="center"/>
			<label posn="40 -65 1" sizen="42 5" text="$9f9{{{NextCheckPersonal}}}" style="TextRaceChrono" textsize="2" halign="center" valign="center"/>
			""";
		}
	}
}

//Update score tables for players
Void UpdateScoresTable(){
	
	declare netwrite Text[] G_PlayersScoresTimes for Teams[0];
	declare netwrite Text[Text] Net_Checkpoints for Teams[0];

	declare Integer[] Times;
	declare CSmPlayer[] PlayerList;
	
	Net_Checkpoints.clear();

	G_PlayersScoresTimes.clear();
	Times.clear();
	PlayerList.clear();

	foreach(Time, G_BestTimes){
		Times.add(Time);
	}

	foreach(Player, Players){
		if(G_CheckpointNext.existskey(Player.Id)){
			if(G_CheckpointNext[Player.Id] > 1 && G_CheckpointNext[Player.Id] - 1 < G_CheckpointsCount){
				Net_Checkpoints[Player.Login] = TextLib::ToText(G_CheckpointNext[Player.Id] - 1);
			} else {
				Net_Checkpoints[Player.Login] = "$609N/A";
			}
		} else {
			Net_Checkpoints[Player.Login] = "$609N/A";
		}
		PlayerList.add(Player);
	}

	Times = Times.sort();
	
	//Players finished
	foreach(Time, Times){
		foreach(Player, PlayerList){
			if(G_BestTimes.existskey(Player.Id) && Time == G_BestTimes[Player.Id] && Time != -1){
				declare Text temp;
				temp = Time ^ "|" ^ Player.Login ^ "|" ^ Player.Name;
				if(!G_PlayersScoresTimes.exists(temp)){
					G_PlayersScoresTimes.add(temp);	
				}
			}
		}
	}
	
	//Players not finished
	foreach(Time, Times){
		foreach(Player, PlayerList){
			if(G_BestTimes.existskey(Player.Id) && Time == G_BestTimes[Player.Id] && Time == -1){
				declare Text temp;
				temp = Time ^ "|" ^ Player.Login ^ "|" ^ Player.Name;
				if(!G_PlayersScoresTimes.exists(temp)){
					G_PlayersScoresTimes.add(temp);	
				}
			}
		}
	}
}

//Checkpoint Managament - INCLUDING FINISH
Void CheckpointManage(CSmPlayer _Player){
	declare Integer[Integer] CheckpointsTimes for _Player;
	declare Integer[Integer] CheckpointsIntTimes for _Player;
	
	declare Integer[Integer] CheckpointsBestTimes for _Player;
	declare Integer[Integer] CheckpointsBestIntTimes for _Player;
	
	declare Integer LastCheckTime for _Player;
	declare Integer diff for _Player;
	declare Integer diffInt for _Player;
	
	CheckpointsTimes[G_CheckpointNext[_Player.Id]] = Now - G_StartsTime[_Player.Id];	
	
	if(G_CheckpointNext[_Player.Id] == 1){
		LastCheckTime = Now - G_StartsTime[_Player.Id];
		CheckpointsIntTimes[G_CheckpointNext[_Player.Id]] = Now - G_StartsTime[_Player.Id];
	} else {
		LastCheckTime = CheckpointsTimes[G_CheckpointNext[_Player.Id]] - (Now - G_StartsTime[_Player.Id]);
		CheckpointsIntTimes[G_CheckpointNext[_Player.Id]] = CheckpointsTimes[G_CheckpointNext[_Player.Id]] - CheckpointsTimes[G_CheckpointNext[_Player.Id] - 1];
	}
	
	//Check if checkpoint absolute times are better
	//If first run
	if(G_Finish[_Player.Id] == 0){
		CheckpointsBestTimes[G_CheckpointNext[_Player.Id]] = CheckpointsTimes[G_CheckpointNext[_Player.Id]];
		G_BestChecks[G_CheckpointNext[_Player.Id]] = CheckpointsBestTimes[G_CheckpointNext[_Player.Id]];
	} else {
		diff = CheckpointsTimes[G_CheckpointNext[_Player.Id]] - CheckpointsBestTimes[G_CheckpointNext[_Player.Id]];
		if(CheckpointsBestTimes[G_CheckpointNext[_Player.Id]] > CheckpointsTimes[G_CheckpointNext[_Player.Id]]){
			CheckpointsBestTimes[G_CheckpointNext[_Player.Id]] = CheckpointsTimes[G_CheckpointNext[_Player.Id]];
			if(G_BestChecks[G_CheckpointNext[_Player.Id]] > CheckpointsBestTimes[G_CheckpointNext[_Player.Id]]){
				G_BestChecks[G_CheckpointNext[_Player.Id]] = CheckpointsBestTimes[G_CheckpointNext[_Player.Id]];
			}
		}
	}
	
	//Check if checkpoint relative times are better
	if(G_Finish[_Player.Id] == 0){
		CheckpointsBestIntTimes[G_CheckpointNext[_Player.Id]] = CheckpointsIntTimes[G_CheckpointNext[_Player.Id]];
	} else {
		diffInt = CheckpointsIntTimes[G_CheckpointNext[_Player.Id]] - CheckpointsBestIntTimes[G_CheckpointNext[_Player.Id]];
		if(CheckpointsBestIntTimes[G_CheckpointNext[_Player.Id]] > CheckpointsIntTimes[G_CheckpointNext[_Player.Id]]){
			CheckpointsBestIntTimes[G_CheckpointNext[_Player.Id]] = CheckpointsIntTimes[G_CheckpointNext[_Player.Id]];
		}
	}
	
	//Check if checkpoint relative times are better (ALL PLAYERS)
	declare Integer diffIntBest;
	
	if(G_BestChecksInt.existskey(G_CheckpointNext[_Player.Id])){
		diffIntBest = CheckpointsBestIntTimes[G_CheckpointNext[_Player.Id]] - G_BestChecksInt[G_CheckpointNext[_Player.Id]];
		if(diffIntBest < 0){
			G_BestChecksInt[G_CheckpointNext[_Player.Id]] = CheckpointsBestIntTimes[G_CheckpointNext[_Player.Id]];
		}
	} else {
		G_BestChecksInt[G_CheckpointNext[_Player.Id]] = CheckpointsBestIntTimes[G_CheckpointNext[_Player.Id]];
	}	
}

//When a player passes checkoint
Void CheckpointEvent(CSmPlayer _Player){	
	declare Integer[Integer] CheckpointsTimes for _Player;
	declare Integer[Integer] CheckpointsIntTimes for _Player;
	
	declare Integer[Integer] CheckpointsBestTimes for _Player;
	declare Integer[Integer] CheckpointsBestIntTimes for _Player;
	
	declare Integer diff for _Player;
	declare Integer diffInt for _Player;
	
	CheckpointManage(_Player);
	
	declare Text diffText;
	declare Text diffIntText;
	
	diffText = "";
	diffIntText = "";
	
	declare sound = 1;
		
	if(G_Finish[_Player.Id] != 0){
		if(diff < 0){
			diffText = " ($66f" ^ TextLib::TimeToText(diff, True) ^ "$fff)";
			sound = 3;
		} else {
			diffText = " ($f66+" ^ TextLib::TimeToText(diff, True) ^ "$fff)";
			sound = 0;
		}
		if(diffInt < 0){
			diffIntText = " ($66f" ^ TextLib::TimeToText(diffInt, True) ^ "$fff)";
			Message::SendBigMessage(_Player, "", 10, 3, CUIConfig::EUISound::Record, 0);
		} else {
			diffIntText = " ($f66+" ^ TextLib::TimeToText(diffInt, True) ^ "$fff)";
		}
	}
	
	
	
	G_CheckpointNext[_Player.Id] += 1;	
	
	Message::SendStatusMessage(_Player, "Time : " ^ TextLib::TimeToText(Now - G_StartsTime[_Player.Id], True) ^ diffText ^ "\nCheckpoint : " ^ TextLib::TimeToText(CheckpointsIntTimes[G_CheckpointNext[_Player.Id] - 1],True) ^ diffIntText, 5000, 3, CUIConfig::EUISound::ScoreProgress, sound);
	UpdateScoresTable();
}

//When a player passes finish
Void FinishEvent(CSmPlayer _Player){	
	CheckpointManage(_Player);

	declare time = Now - G_StartsTime[_Player.Id];
	declare diffFinal = time - G_BestTimes[_Player.Id];
	
	declare Text diffFinalText;
	declare newRecord = False;
		
	G_PreviousTimes[_Player.Id] = time;
	
	//if first run
	if(G_Finish[_Player.Id] == 0){
		G_BestTimes[_Player.Id] = G_PreviousTimes[_Player.Id];
		diffFinalText = "";
	} else {
		//Check if best time
		if(diffFinal < 0){
			G_BestTimes[_Player.Id] = G_PreviousTimes[_Player.Id];
			newRecord = True;
			diffFinalText = " ($00f" ^ TextLib::TimeToText(diffFinal, True) ^ "$fff)";
		} else {
			diffFinalText = " ($f00+" ^ TextLib::TimeToText(diffFinal, True) ^ "$fff)";
		}
	}
	
	if(newRecord){
		Message::SendStatusMessage(_Player, "Final time : " ^ TextLib::TimeToText(Now - G_StartsTime[_Player.Id], True) ^ diffFinalText, 5000, 3, CUIConfig::EUISound::VictoryPoint, 0);
	} else {
		Message::SendStatusMessage(_Player, "Final time : " ^ TextLib::TimeToText(Now - G_StartsTime[_Player.Id], True) ^ diffFinalText, 5000, 3, CUIConfig::EUISound::EndMatch, 0);
	}
	
	//Send
	SendXmlRpcCallback("OnFinish", _Player, time, G_Checkpoints[G_CheckpointNext[_Player.Id]].Id);
	
	//Unspawn player and stuff
	UnspawnPlayer(_Player);
	G_Finish[_Player.Id] += 1;
	G_CheckpointNext[_Player.Id] = 0;
	Chrono::Stop(_Player.Id);
	Chrono::Reset(_Player.Id);
	
	SendNotice(_Player, "Run completed.");
	UpdateScoresTable();
	G_FinishAny = True;
}

Text CreateUIEventManager(){
	declare Manialink = """
		<script><!--

		declare netwrite ShowOptionsMenu for UI = 0;
		declare Text RespawnKeyToggle for UI;

		declare netwrite RespawnAtStart for UI = False;

		while (True) {
			yield;
			// Process events
			foreach (Event in PendingEvents) {
				switch (Event.Type) {
					case CMlEvent::Type::MouseClick: {
						if(Event.ControlId == "closeOptionsMenu"){
							ShowOptionsMenu = 0;
						}
					}
					case CMlEvent::Type::KeyPress: {
						if(Event.KeyName == RespawnKeyToggle){
							RespawnAtStart = !RespawnAtStart;
						}
					}
				}
			}
		}
		--></script>
	""";
	return Manialink;
}

Text CreateScoresTable(){
	declare Manialink = """
		<script><!--

		#Include "TextLib" as TextLib
		#Include "MathLib" as MathLib
		

		declare Buttons = [(Page.GetFirstChild("prev") as CMlQuad), (Page.GetFirstChild("next") as CMlQuad)];

		declare Scores = [(Page.GetFirstChild("Scores") as CMlFrame)];

		declare Labels = [
			(Page.GetFirstChild("currentPage") as CMlLabel),
			(Page.GetFirstChild("1") as CMlLabel),
			(Page.GetFirstChild("2") as CMlLabel),
			(Page.GetFirstChild("3") as CMlLabel),
			(Page.GetFirstChild("4") as CMlLabel),
			(Page.GetFirstChild("5") as CMlLabel),
			(Page.GetFirstChild("6") as CMlLabel),
			(Page.GetFirstChild("7") as CMlLabel),
			(Page.GetFirstChild("8") as CMlLabel),
			(Page.GetFirstChild("9") as CMlLabel),
			(Page.GetFirstChild("10") as CMlLabel)
			];

		declare LabelsTime = [
			(Page.GetFirstChild("time1") as CMlLabel),
			(Page.GetFirstChild("time2") as CMlLabel),
			(Page.GetFirstChild("time3") as CMlLabel),
			(Page.GetFirstChild("time4") as CMlLabel),
			(Page.GetFirstChild("time5") as CMlLabel),
			(Page.GetFirstChild("time6") as CMlLabel),
			(Page.GetFirstChild("time7") as CMlLabel),
			(Page.GetFirstChild("time8") as CMlLabel),
			(Page.GetFirstChild("time9") as CMlLabel),
			(Page.GetFirstChild("time10") as CMlLabel)
			];

		declare LabelsCP = [
			(Page.GetFirstChild("cp1") as CMlLabel),
			(Page.GetFirstChild("cp2") as CMlLabel),
			(Page.GetFirstChild("cp3") as CMlLabel),
			(Page.GetFirstChild("cp4") as CMlLabel),
			(Page.GetFirstChild("cp5") as CMlLabel),
			(Page.GetFirstChild("cp6") as CMlLabel),
			(Page.GetFirstChild("cp7") as CMlLabel),
			(Page.GetFirstChild("cp8") as CMlLabel),
			(Page.GetFirstChild("cp9") as CMlLabel),
			(Page.GetFirstChild("cp10") as CMlLabel)
			];

		declare LabelPlayers = [
			(Page.GetFirstChild("players") as CMlLabel)
		];


		declare LabelOptionsMenu = [(Page.GetFirstChild("showOptionsMenu") as CMlLabel)];

		declare netread Text[] G_PlayersScoresTimes for Teams[0];
		declare netread Text[Text] Net_Checkpoints for Teams[0];

		declare netread Integer Net_PlayersCount for Teams[0];

		declare netwrite Integer currentPage for UI;
		declare ShowOptionsMenu for UI = 0;
		declare netwrite SpecTarget for UI = "";

		currentPage = 0;

		while (True) {
			if(ShowOptionsMenu == 0){
				Scores[0].Visible = True;
			} else {
				Scores[0].Visible = False;
			}
			if(Net_PlayersCount < 7){
				currentPage = 0;
			}
			LabelPlayers[0].Value = "Players : " ^ Net_PlayersCount;
			
			declare firstTime = 0;
			if(Net_PlayersCount > 7){
				Labels[0].Value = TextLib::ToText(currentPage + 1) ^ "/" ^ TextLib::ToText(MathLib::CeilingInteger(Net_PlayersCount/10.0));
			} else {
				Labels[0].Value = "";
			}

			if(G_PlayersScoresTimes.existskey(currentPage * 10 + 0)){
				Labels[1].Value = TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10])[2];
				declare time = TextLib::ToInteger(TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10])[0]);
				firstTime = TextLib::ToInteger(TextLib::Split("|", G_PlayersScoresTimes[0])[0]);
				LabelsTime[0].Value = TextLib::TimeToText(time, True);
				if(currentPage == 0){
					if(time != -1){
						LabelsTime[0].Value = "$FF6" ^ LabelsTime[0].Value;
					} else {
						LabelsTime[0].Value = "--:--.--";
					}
				} else {
					if(time != -1){
						LabelsTime[0].Value = "$FF6" ^ LabelsTime[0].Value;	
					} else {
						LabelsTime[0].Value = "--:--.--";
					}
				}
				LabelsCP[0].Value = "$609" ^ Net_Checkpoints[TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10])[1]];
			} else {
				LabelsCP[0].Value = "$609N/A";
				Labels[1].Value = "No Player";
				LabelsTime[0].Value = "--:--.--";
				if(currentPage == 0){
					LabelsTime[0].Value = "$FF6" ^ LabelsTime[0].Value;
				}
			}

			declare index = 1;

			while(index < 10){
				if(G_PlayersScoresTimes.existskey(currentPage * 10 + index)){
					Labels[1 + index].Value = TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10 + index])[2];
					declare time = TextLib::ToInteger(TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10 + index])[0]);
					LabelsTime[index].Value = TextLib::TimeToText(time, True);
					if(currentPage == 0){
						LabelsTime[index].Value = "$FF6" ^ LabelsTime[index].Value;
					}
					if(time != -1){
						LabelsTime[index].Value = "$FF6" ^ LabelsTime[index].Value;
					} else {
							LabelsTime[index].Value = "--:--.--";
					}
					LabelsCP[index].Value = "$609" ^ Net_Checkpoints[TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10 + index])[1]];
				} else {
					LabelsCP[index].Value = "$609N/A";
					Labels[1 + index].Value = "No Player";
					LabelsTime[index].Value = "--:--.--";
					if(currentPage == 0){
						LabelsTime[index].Value = "$FF6" ^ LabelsTime[index].Value;
					}
				}
				index += 1;
			}

			// Process events
			foreach (Event in PendingEvents) {
				switch(Event.Type){
					case CMlEvent::Type::MouseClick:{
						if(Event.ControlId == "prev"){
							if(currentPage > 0){
								currentPage -= 1;
							}
						}
						if(Event.ControlId == "next"){
							if(currentPage < MathLib::CeilingInteger(Net_PlayersCount/10.0) - 1){
								currentPage += 1;
							}
						}
						if(Event.ControlId == "spec1"){
							if(G_PlayersScoresTimes.existskey(currentPage * 10 + 0)){
								SpecTarget = TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10])[1];
							}
						}
						if(Event.ControlId == "spec2"){
							if(G_PlayersScoresTimes.existskey(currentPage * 10 + 1)){
								SpecTarget = TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10 + 1])[1];
							}
						}
						if(Event.ControlId == "spec3"){
							if(G_PlayersScoresTimes.existskey(currentPage * 10 + 2)){
								SpecTarget = TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10 + 2])[1];
							}
						}
						if(Event.ControlId == "spec4"){
							if(G_PlayersScoresTimes.existskey(currentPage * 10 + 3)){
								SpecTarget = TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10 + 3])[1];
							}
						}
						if(Event.ControlId == "spec5"){
							if(G_PlayersScoresTimes.existskey(currentPage * 10 + 4)){
								SpecTarget = TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10 + 4])[1];
							}
						}
						if(Event.ControlId == "spec6"){
							if(G_PlayersScoresTimes.existskey(currentPage * 10 + 5)){
								SpecTarget = TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10 + 5])[1];
							}
						}
						if(Event.ControlId == "spec7"){
							if(G_PlayersScoresTimes.existskey(currentPage * 10 + 6)){
								SpecTarget = TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10 + 6])[1];
							}
						}
						if(Event.ControlId == "spec8"){
							if(G_PlayersScoresTimes.existskey(currentPage * 10 + 6)){
								SpecTarget = TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10 + 7])[1];
							}
						}
						if(Event.ControlId == "spec9"){
							if(G_PlayersScoresTimes.existskey(currentPage * 10 + 6)){
								SpecTarget = TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10 + 8])[1];
							}
						}
						if(Event.ControlId == "spec10"){
							if(G_PlayersScoresTimes.existskey(currentPage * 10 + 6)){
								SpecTarget = TextLib::Split("|", G_PlayersScoresTimes[currentPage * 10 + 9])[1];
							}
						}
					}
				}
			}
			yield;
		}
		--></script>
		<frame id="Scores" posn="0 8 0">
			<label posn="-78 37 1" sizen="133 3" text="{{{MapName}}} by {{{Map.AuthorNickName}}} ({{{Map.AuthorLogin}}})" textsize="1"/>
			<label posn="-78 33 1" sizen="151 4" text="Server : {{{ServerName}}}" textsize="1"/>
			<quad posn="0 -13.5 0" sizen="160 104" bgcolor="101010AA" halign="center" valign="center"/>
			<frame posn="0 2 0">
				<label posn="-75 24 1" sizen="69 5" text="NickName" valign="center" halign="left" textsize="2"/>
				<label posn="4 23 1" sizen="20 5" text="CP" textsize="2" halign="center" valign="center"/>
				<label posn="73 24 1" sizen="40 5" text="Time" valign="center" halign="right" textsize="2"/>
				<quad posn="0 -21 0.5" sizen="158 82" bgcolor="03142AAA" halign="center" valign="center"/>

				<frame posn="-10 25 1">
					<quad posn="-68 -10 0" sizen="156 7" bgcolor="111111C6" halign="left" valign="center"/>
					<label id="1" posn="-61 -10 0" sizen="70 5" text="No player" valign="center" halign="left" textsize="2"/>
					<quad posn="-67 -7 1" sizen="6 6" bgcolor="FFFA" style="UIConstruction_Buttons" substyle="Camera" scriptevents="1" id="spec1"/>
					<label id="time1" posn="85 -8 0" sizen="60 6" text="--:--.--" style="TextCardMedium" textsize="3" halign="right"/>
					<label posn="14 -10 1" sizen="13 5" text="$609N/A" id="cp1" style="UiDriving_BgBottom" textsize="2" halign="center" valign="center"/>
				</frame>

				<frame posn="-10 17 1">
					<quad posn="-68 -10 0" sizen="156 7" bgcolor="111111C6" halign="left" valign="center"/>
					<label id="2" posn="-61 -10 0" sizen="70 5" text="No player" valign="center" halign="left" textsize="2"/>
					<quad posn="-67 -7 1" sizen="6 6" bgcolor="FFFA" style="UIConstruction_Buttons" substyle="Camera" scriptevents="1" id="spec2"/>
					<label id="time2" posn="85 -8 0" sizen="60 6" text="--:--.--" style="TextCardMedium" textsize="3" halign="right"/>
					<label posn="14 -10 1" sizen="13 5" text="$609N/A" id="cp2" style="UiDriving_BgBottom" textsize="2" halign="center" valign="center"/>
				</frame>

				<frame posn="-10 9 1">
					<quad posn="-68 -10 0" sizen="156 7" bgcolor="111111C6" halign="left" valign="center"/>
					<label id="3" posn="-61 -10 0" sizen="70 5" text="No player" valign="center" halign="left" textsize="2"/>
					<quad posn="-67 -7 1" sizen="6 6" bgcolor="FFFA" style="UIConstruction_Buttons" substyle="Camera" scriptevents="1" id="spec3"/>
					<label id="time3" posn="85 -8 0" sizen="60 6" text="--:--.--" style="TextCardMedium" textsize="3" halign="right"/>
					<label posn="14 -10 1" sizen="13 5" text="$609N/A" id="cp3" style="UiDriving_BgBottom" textsize="2" halign="center" valign="center"/>
				</frame>

				<frame posn="-10 1 1">
					<quad posn="-68 -10 0" sizen="156 7" bgcolor="111111C6" halign="left" valign="center"/>
					<label id="4" posn="-61 -10 0" sizen="70 5" text="No player" valign="center" halign="left" textsize="2"/>
					<quad posn="-67 -7 1" sizen="6 6" bgcolor="FFFA" style="UIConstruction_Buttons" substyle="Camera" scriptevents="1" id="spec4"/>
					<label id="time4" posn="85 -8 0" sizen="60 6" text="--:--.--" style="TextCardMedium" textsize="3" halign="right"/>
					<label posn="14 -10 1" sizen="13 5" text="$609N/A" id="cp4" style="UiDriving_BgBottom" textsize="2" halign="center" valign="center"/>
				</frame>

				<frame posn="-10 -7 1">
					<quad posn="-68 -10 0" sizen="156 7" bgcolor="111111C6" halign="left" valign="center"/>
					<label id="5" posn="-61 -10 0" sizen="70 5" text="No player" valign="center" halign="left" textsize="2"/>
					<quad posn="-67 -7 1" sizen="6 6" bgcolor="FFFA" style="UIConstruction_Buttons" substyle="Camera" scriptevents="1" id="spec5"/>
					<label id="time5" posn="85 -8 0" sizen="60 6" text="--:--.--" style="TextCardMedium" textsize="3" halign="right"/>
					<label posn="14 -10 1" sizen="13 5" text="$609N/A" id="cp5" style="UiDriving_BgBottom" textsize="2" halign="center" valign="center"/>
				</frame>

				<frame posn="-10 -15 1">
					<quad posn="-68 -10 0" sizen="156 7" bgcolor="111111C6" halign="left" valign="center"/>
					<label id="6" posn="-61 -10 0" sizen="70 5" text="No player" valign="center" halign="left" textsize="2"/>
					<quad posn="-67 -7 1" sizen="6 6" bgcolor="FFFA" style="UIConstruction_Buttons" substyle="Camera" scriptevents="1" id="spec6"/>
					<label id="time6" posn="85 -8 0" sizen="60 6" text="--:--.--" style="TextCardMedium" textsize="3" halign="right"/>
					<label posn="14 -10 1" sizen="13 5" text="$609N/A" id="cp6" style="UiDriving_BgBottom" textsize="2" halign="center" valign="center"/>
				</frame>

				<frame posn="-10 -23 1">
					<quad posn="-68 -10 0" sizen="156 7" bgcolor="111111C6" halign="left" valign="center"/>
					<label id="7" posn="-61 -10 0" sizen="70 5" text="No player" valign="center" halign="left" textsize="2"/>
					<quad posn="-67 -7 1" sizen="6 6" bgcolor="FFFA" style="UIConstruction_Buttons" substyle="Camera" scriptevents="1" id="spec7"/>
					<label id="time7" posn="85 -8 0" sizen="60 6" text="--:--.--" style="TextCardMedium" textsize="3" halign="right"/>
					<label posn="14 -10 1" sizen="13 5" text="$609N/A" id="cp7" style="UiDriving_BgBottom" textsize="2" halign="center" valign="center"/>
				</frame>

				<frame posn="-10 -31 1">
					<quad posn="-68 -10 0" sizen="156 7" bgcolor="111111C6" halign="left" valign="center"/>
					<label id="8" posn="-61 -10 0" sizen="70 5" text="No player" valign="center" halign="left" textsize="2"/>
					<quad posn="-67 -7 1" sizen="6 6" bgcolor="FFFA" style="UIConstruction_Buttons" substyle="Camera" scriptevents="1" id="spec8"/>
					<label id="time8" posn="85 -8 0" sizen="60 6" text="--:--.--" style="TextCardMedium" textsize="3" halign="right"/>
					<label posn="14 -10 1" sizen="13 5" text="$609N/A" id="cp8" style="UiDriving_BgBottom" textsize="2" halign="center" valign="center"/>
				</frame>

				<frame posn="-10 -39 1">
					<quad posn="-68 -10 0" sizen="156 7" bgcolor="111111C6" halign="left" valign="center"/>
					<label id="9" posn="-61 -10 0" sizen="70 5" text="No player" valign="center" halign="left" textsize="2"/>
					<quad posn="-67 -7 1" sizen="6 6" bgcolor="FFFA" style="UIConstruction_Buttons" substyle="Camera" scriptevents="1" id="spec9"/>
					<label id="time9" posn="85 -8 0" sizen="60 6" text="--:--.--" style="TextCardMedium" textsize="3" halign="right"/>
					<label posn="14 -10 1" sizen="13 5" text="$609N/A" id="cp9" style="UiDriving_BgBottom" textsize="2" halign="center" valign="center"/>
				</frame>
				
				<frame posn="-10 -47 1">
					<quad posn="-68 -10 0" sizen="156 7" bgcolor="111111C6" halign="left" valign="center"/>
					<label id="10" posn="-61 -10 0" sizen="70 5" text="No player" valign="center" halign="left" textsize="2"/>
					<quad posn="-67 -7 1" sizen="6 6" bgcolor="FFFA" style="UIConstruction_Buttons" substyle="Camera" scriptevents="1" id="spec10"/>
					<label id="time10" posn="85 -8 0" sizen="60 6" text="--:--.--" style="TextCardMedium" textsize="3" halign="right"/>
					<label posn="14 -10 1" sizen="13 5" text="$609N/A" id="cp10" style="UiDriving_BgBottom" textsize="2" halign="center" valign="center"/>
				</frame>

				<quad id="next" posn="72 -62 1" sizen="6 6" bgcolor="FFFA" style="Icons64x64_1" substyle="ArrowNext" scriptevents="1"/>
				<quad id="prev" posn="67 -62 1" sizen="6 6" bgcolor="FFFA" style="Icons64x64_1" substyle="ArrowPrev" scriptevents="1"/>
				<label id="currentPage" posn="0 -64 1" sizen="20 5" text="[currentPage]" valign="center" halign="center" textsize="2"/>
				<label id="players" posn="-77 -64 1" sizen="58 5" text="Players" textsize="2" valign="center"/>
			</frame>			
		</frame>
		""";

	return Manialink;
}

Void CreateUIOptionsMenu(){
	
	G_OptionsMenu.ManialinkPage = """
		<script><!--
		declare ShowOptionsMenu for UI = 0;

		declare Frame = [(Page.GetFirstChild("OptionsMenu") as CMlFrame)];

		declare Labels = [
			(Page.GetFirstChild("showOptionsMenu") as CMlLabel),
			(Page.GetFirstChild("showHud") as CMlLabel),
			(Page.GetFirstChild("extraHud") as CMlLabel),
			(Page.GetFirstChild("respawnKeyDefault") as CMlLabel)
		];

		declare netwrite SwitchFullHud for UI = False;
		declare netwrite SwitchExtraHud for UI = False;

		declare RespawnKeyToggleEdit for UI = False;
		declare RespawnKeyToggle for UI = "F4";		

		while (True) {
			if(Frame[0].Visible && ShowOptionsMenu == 0){
				Frame[0].Visible = False;
				Labels[0].Visible = True;
			}
			if(!Frame[0].Visible && ShowOptionsMenu == 1){
				Frame[0].Visible = True;
				Labels[0].Visible = False;
			}
			if(SwitchFullHud){
			Labels[1].Value = "Yes";
			} else {
				Labels[1].Value = "No";
			}
			if(SwitchExtraHud){
				Labels[2].Value = "Yes";
			} else {
				Labels[2].Value = "No";
			}
			if(!RespawnKeyToggleEdit){
				Labels[3].Value = RespawnKeyToggle;
			} else {
				Labels[3].Value = "Press new key";
			}		
			yield;
			// Process events
			foreach (Event in PendingEvents) {
				switch (Event.Type) {
					case CMlEvent::Type::MouseClick: {
						if(Event.ControlId == "closeOptionsMenu"){
							ShowOptionsMenu = 0;
						}
						if(Event.ControlId == "showOptionsMenu"){
							if(ShowOptionsMenu == 0){
								ShowOptionsMenu = 1;
							} else {
								ShowOptionsMenu = 0;
							}
						}
						if(Event.ControlId == "showHud"){
							SwitchFullHud = !SwitchFullHud;
							
						}
						if(Event.ControlId == "extraHud"){
							SwitchExtraHud = !SwitchExtraHud;
						}
						if(Event.ControlId == "respawnKeyDefault"){
							RespawnKeyToggleEdit = True;

						}
					}
					case CMlEvent::Type::KeyPress: {
						if(RespawnKeyToggleEdit){
							RespawnKeyToggleEdit = False;
							RespawnKeyToggle = Event.KeyName;
						}
					}
				}
			}
		}
		--></script>
		<label posn="-158 88 0" halign="left" style="TextButtonNav" text="(Work in Progress) Obstacle Reborn Revision : {{{C_Revision}}}" />
		<label id="showOptionsMenu" posn="-159 82 0" sizen="83 5" autonewline="1" text="Options" textsize="2" scriptevents="1" style="CardButtonMedium"/>
		<frame id="OptionsMenu">
		<quad posn="0 0 0" sizen="181 98" bgcolor="000000C6" valign="center" halign="center"/>
		<label posn="-88 47 1" sizen="70 6" text="Options" style="TextTitle3" textsize="3"/>
		<label posn="-87 37 1" sizen="70 6" text="HUD Options" style="TextTitle3" textsize="2"/>
		<label posn="-86 30 1" sizen="69 5" text="Show Info Hud" textsize="2"/>
		<label posn="-83 25 1" sizen="116 10" text="$aafShow/Hide what values means. (Best Time, Previous time, Respawns, Runs, CP Progress, Best Theoretical, All Best Theoretical)" textsize="2" autonewline="1"/>
		<label posn="37 25 1" sizen="20 5" text="Yes" style="CardButtonMediumXL" scriptevents="1" id="showHud"/>
		<label posn="-86 14 1" sizen="69 5" text="Show Extra Hud" textsize="2"/>
		<label posn="-83 9 1" sizen="116 10" text="$aafShow/Hide extra stuff : Previous CP Info and Next CP Info" textsize="2" autonewline="1"/>
		<label posn="37 9 1" sizen="20 5" text="Yes" style="CardButtonMediumXL" scriptevents="1" id="extraHud"/>
		<label posn="-87 -4 1" sizen="70 6" text="Other Options" style="TextTitle3" textsize="2"/>
		<label posn="-86 -10 1" sizen="69 5" text="Respawn behaviour key" textsize="2"/>
		<label posn="37 -14 1" sizen="20 5" text="F4" style="CardButtonMediumXL" scriptevents="1" id="respawnKeyDefault"/>
		<label posn="-83 -15 1" sizen="116 10" text="$aafRespawn at start or at last CP passed. Rebind key." textsize="2" autonewline="1"/>
		<label posn="-90 -36 1" sizen="20 5" text="Close" style="CardMain_Quit" scriptevents="1" id="closeOptionsMenu"/>
		</frame>
	""";
}

Void InitInterface(){

	UIManager.UIAll.ScoreTableOnlyManialink = True;
	UIManager.UIAll.AltMenuNoCustomScores = False;
	
	G_UIEventManager = UIManager.UILayerCreate();
	G_UIEventManager.ManialinkPage = CreateUIEventManager();
	UIManager.UIAll.UILayers.add(G_UIEventManager);

	G_ScoresTable = UIManager.UILayerCreate();
	G_ScoresTable.Type = CUILayer::EUILayerType::ScoresTable;
	UIManager.UIAll.UILayers.add(G_ScoresTable);
	
	G_OptionsMenu = UIManager.UILayerCreate();
	//G_OptionsMenu.Type = CUILayer::EUILayerType::ScoresTable;
	CreateUIOptionsMenu();
	UIManager.UIAll.UILayers.add(G_OptionsMenu);

	Chrono::Load();

	SM::SetupDefaultVisibility();
}

Void InitObstacle(){
	
	// Set mode options
	UseClans = False;

	UsePvPCollisions = False;
	UsePvPWeapons = False;
	UseSameWallJump = True;
	
	
	
	G_CheckpointsCount = 0;
	
	declare CSmMapLandmark[] ChecksRaw;
	
	ChecksRaw.clear();
	G_StartsTime = Integer[Ident];
	G_BestChecksInt = Integer[Integer];
	G_BestChecks = Integer[Integer];

	foreach(Player, Players){
		G_Finish[Player.Id] = 0;
	}

	//Colors
	foreach(Base, MapBases){
		Base.Clan = 0;
		Base.IsActive = True;
	}
	
	//Get Spawns
	foreach(Spawn, MapLandmarks_PlayerSpawn){
		if(TextLib::SubText(Spawn.Tag, 0, 5) == "Spawn"){
			G_MainSpawn <=> Spawn;
		}
	}
	
	//Get checkpoint count
	foreach(Checkpoint, MapLandmarks_Gauge){	
		if(TextLib::SubText(Checkpoint.Tag, 0, 10) == "Checkpoint"){
			ChecksRaw.add(Checkpoint);
			G_CheckpointsCount += 1;
		}
	}
	
	//Reorganise
	for(i, 1, G_CheckpointsCount){
		declare CSmMapLandmark nextCheck;
	
		foreach(CurCheck, ChecksRaw){
			//First one
			if(nextCheck == Null){
				if(TextLib::SubText(CurCheck.Tag, 0, 10) == "Checkpoint"){
					nextCheck <=> CurCheck;
				}
			} else {
				if(CurCheck.Order < nextCheck.Order && TextLib::SubText(CurCheck.Tag, 0, 10) == "Checkpoint"){
					nextCheck <=> CurCheck;
				}
			}
		}
		
		G_Checkpoints[i] <=> nextCheck;
		declare removed = ChecksRaw.remove(nextCheck);
	}
	
	//Add goal retro compatibility
	if(Map.MapType != "ObstacleRebornArena"){
		foreach(FinishFind, MapLandmarks_Gauge){
			if(FinishFind.Tag == "Goal"){
				G_CheckpointsCount += 1;
				G_Checkpoints[G_CheckpointsCount] <=> FinishFind;
			}
		}
	}
}

Void UpdatePlayersObstacle(){
	declare netwrite Integer Net_PlayersCount for Teams[0];

	Net_PlayersCount = AllPlayers.count;

	//Players
	foreach(Player, AllPlayers){
		if(!Player.RequestsSpectate){				
			if(Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned){		
				OSpawnPlayer(Player);
				G_CheckpointNext[Player.Id] = 0;
				G_Respawns[Player.Id] = 0;
			}
			if(Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned && G_CheckpointNext[Player.Id] == 0){
				G_StartsTime[Player.Id] = Now;
				G_CheckpointNext[Player.Id] = 1;
				Chrono::Start(Player.Id, 0);
			}
			
			if(G_Stamina[Player.Id]){
				Player.Stamina = 3600;
			}
			
			if(Player.CapturedLandmark != Null){
				if(TextLib::SubText(Player.CapturedLandmark.Tag, 0, 4) == "Goal"){
					if(G_CheckpointNext[Player.Id] == G_CheckpointsCount){
						FinishEvent(Player);
					}
				}
				if(TextLib::SubText(Player.CapturedLandmark.Tag, 0, 10) == "Checkpoint"){
					if(Player.CapturedLandmark.Order == G_Checkpoints[G_CheckpointNext[Player.Id]].Order){
						if(G_CheckpointNext[Player.Id] == G_CheckpointsCount){
							FinishEvent(Player);
						} else {
							ChangeAmmo(Player);
							ChangeStamina(Player);
							CheckpointEvent(Player);
						}
					}
				}
			}
				
		}
		if(Player.RequestsSpectate){
			G_CheckpointNext[Player.Id] = 0;
			Chrono::Stop(Player.Id);
			Chrono::Reset(Player.Id);
		}
		
		
		//Respawns + Restarts
		declare UI = UIManager.GetUI(Player);
				
		UpdatePlayerInterface(Player);
	}
	
	//Events
	foreach(Event, PendingEvents){
		switch(Event.Type){
			case CSmModeEvent::EType::OnPlayerRequestRespawn : {
				Discard(Event);
				RestartPlayer(Event.Player);
			}
			case CSmModeEvent::EType::OnArmorEmpty : {
				Discard(Event);
				RestartPlayer(Event.Victim);
			}
		}
	}
}