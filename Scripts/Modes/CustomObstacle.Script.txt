/**
 *	Obstacle Custom GameMode
 *  Author : kana & lethan
 *  Original author : steeffeen
 */

// ---------------------------------- //
// Requirements
// ---------------------------------- //
#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/ChronoObs.Script.txt" as Chrono
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen

// ---------------------------------- //
// Settings
// ---------------------------------- //

#Const Description _("Obstacle Custom GameMode\nOriginal Author : Steeffeen\nRework : kana & lethan")
#Const UITickPeriod 200

// ---------------------------------- //
// Global var
// ---------------------------------- //
declare Text _GamePhase;

declare CSmMapLandmark _MainSpawn;
declare CSmMapLandmark[] _ChecksRaw;
declare CSmMapLandmark[Integer] _Checkpoints;

declare Integer[Ident] _StartTimes;
declare Integer[Ident] _CheckpointCurrent;

declare Integer _CheckpointsCount;

// ---------------------------------- //
// Set rules
// ---------------------------------- //
***Rules***
***
declare ModeName = "Custom Obstacle";
declare ModeRules = TextLib::Compose(_("Obstacle Custom GameMode\nOriginal Author : Steeffeen\nRework : kana & lethan"), "$"^SpawnScreen::GetModeColor());
SpawnScreen::ResetRulesSection();
SpawnScreen::AddSubsection(_("Obstacle Custom GameMode"), ModeRules, 20.);
SpawnScreen::CreatePrettyRules(ModeName);
ModeStatusMessage = _("Obstacle Custom GameMode\nOriginal Author : Steeffeen\nRework : kana & lethan");
***

// ---------------------------------- //
// Server start
// ---------------------------------- //
***StartServer***
***
// ---------------------------------- //
// Set mode options
UseClans = False;
UseAllies = False;
// ---------------------------------- //
// Create the rules
---Rules---

// ---------------------------------- //
// Initialize UI
SpawnScreen::CreateScores("Score.RoundPoints");
SpawnScreen::CreateMapInfo();
//Interface::CreateRank();

// ---------------------------------- //
// Create the scores table
ST2::SetStyle("LibST_SMBaseSolo");
ST2::SetStyle("LibST_SMBasePoints");
MB_SetScoresTableStyleFromXml(S_ScoresTableStylePath);
ST2::Build("SM");
***


// ---------------------------------- //
// Map start
// ---------------------------------- //
***StartMap***
***
_GamePhase = "init";

Score::MatchBegin();
SM::SetupDefaultVisibility();
Chrono::Load();

InitObstacle();

// Init bases
foreach (Base in MapBases) {
	Base.Clan = 1;
	Base.IsActive = True;
}


UIManager.UIAll.UISequence = CUIConfig::EUISequence::Intro;

***

// ---------------------------------- //
// Play loop
// ---------------------------------- //
***PlayLoop***
***
CheckForNewPlayers();

if(_GamePhase == "init"){
	sleep(2000);
	declare Text authorMsg = "Author : " ^ Map.AuthorNickName ^ " (" ^ Map.AuthorLogin ^ ")";
	Message::SendStatusMessage(authorMsg, 5000, 3, CUIConfig::EUISound::Silence, 0);
	Message::SendBigMessage(MapName, 5000, 3, CUIConfig::EUISound::EndRound, 0);

	sleep(2000);
	
	StartTime = Now;
	EndTime = -1;
	
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
		
	_GamePhase = "play";
	
	
}
if(_GamePhase == "play"){
	//Players
	foreach(Player, Players){	
		if(_StartTimes.existskey(Player.Id) && Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned){
			COSpawnPlayer(Player);
		}
		if(Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
			if(_StartTimes.existskey(Player.Id)){
				if(_CheckpointCurrent[Player.Id] == 0){
					Chrono::Reset(Player.Id);
					Chrono::Start(Player.Id, 0);
					_StartTimes[Player.Id] = Now;
					_CheckpointCurrent[Player.Id] = 1;
					UpdateMarkerCheckpoint(Player, False);
				}
			}
		}
		
		if(Player.CapturedLandmark != Null){
			if(_Checkpoints[_CheckpointCurrent[Player.Id]] == Player.CapturedLandmark){
				if(_CheckpointCurrent[Player.Id] == _CheckpointsCount){
					UpdateMarkerCheckpoint(Player, True);
					UnspawnPlayer(Player);
					Chrono::Stop(Player.Id);
					_CheckpointCurrent[Player.Id] = 0;
					
					Message::SendStatusMessage(Player, "Finish !", 2000, 3, CUIConfig::EUISound::VictoryPoint, 1);
					Message::SendBigMessage("Score : " ^ (Now - _StartTimes[Player.Id]), 5000, 3, CUIConfig::EUISound::Silence, 0);
				} else {
					Message::SendStatusMessage(Player, "Checkpoint ! " ^ _CheckpointCurrent[Player.Id] ^ "/" ^ _CheckpointsCount, 5000, 3, CUIConfig::EUISound::ScoreProgress, _CheckpointCurrent[Player.Id]);
					_CheckpointCurrent[Player.Id] += 1;
					UpdateMarkerCheckpoint(Player, False);
				}
			}
		}
	}
	
	
}

Message::Loop();
***


// ---------------------------------- //
// Map end
// ---------------------------------- //
/****EndMap***
***
****/
// ---------------------------------- //
// Server end
// ---------------------------------- //
***EndServer***
***
UIManager.UILayerDestroyAll();
Interface::DestroyRank();
SpawnScreen::DestroyRules();
SpawnScreen::DestroyScores();
SpawnScreen::DestroyMapInfo();
***

//Functions
Void CheckForNewPlayers(){
	foreach(Player, Players){	
		if(!_StartTimes.existskey(Player.Id)) {
			_StartTimes[Player.Id] = 0;
			_CheckpointCurrent[Player.Id] = 0;
			Chrono::Create(Player.Id);
		}
	}
}

Void UpdateMarkerCheckpoint(CSmPlayer _Player, Boolean _Finish){
	declare UI <=> UIManager.GetUI(_Player);
	
	declare cpCurrent = _CheckpointCurrent[_Player.Id];
	
	log(cpCurrent ^ " - " ^ _CheckpointsCount);
	
	if(!_Finish){
		if(cpCurrent != _CheckpointsCount){
			UI.MarkersXML = """<marker label="CP {{{cpCurrent}}}" pos="{{{_Checkpoints[cpCurrent].Position.X}}} {{{_Checkpoints[cpCurrent].Position.Y + 2}}} {{{_Checkpoints[cpCurrent].Position.Z}}}" />""";
		} else {
			UI.MarkersXML = """<marker label="Finish" pos="{{{_Checkpoints[cpCurrent].Position.X}}} {{{_Checkpoints[cpCurrent].Position.Y + 2}}} {{{_Checkpoints[cpCurrent].Position.Z}}}" />""";
		}
	} else {
		UI.MarkersXML = "";
	}
}

Void InitObstacle(){
	_CheckpointsCount = 0;
	_ChecksRaw.clear();
	_StartTimes.clear();
	
	UIManager.UIAll.OverlayHideMapInfo = False;
	
	//Get Spawns
	foreach(Spawn, MapLandmarks_PlayerSpawn){
		if(Spawn.Tag == "Spawn"){
			_MainSpawn <=> Spawn;
		}
	}
	
	//Get checkpoint count
	foreach(Checkpoint, MapLandmarks_Gauge){
		if(Checkpoint.Tag == "Checkpoint"){
			_ChecksRaw.add(Checkpoint);
			_CheckpointsCount += 1;
		}
	}
	
	//Reorganise
	for(i, 1, _CheckpointsCount){
		declare CSmMapLandmark nextCheck;
	
		foreach(CurCheck, _ChecksRaw){
		//First one
			if(nextCheck == Null){
			nextCheck <=> CurCheck;
			} else {
				if(CurCheck.Order < nextCheck.Order){
					nextCheck <=> CurCheck;
				}
			}
		}
		
		_Checkpoints[i] <=> nextCheck;
		declare removed = _ChecksRaw.remove(nextCheck);
	}
}

Void COSpawnPlayer(CSmPlayer _Player){
	_Player.ArmorMax = 100;
	SpawnPlayer(_Player, 0, 100, _MainSpawn.PlayerSpawn, Now);
}